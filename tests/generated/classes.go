// Code generated by wazero-emscripten-embind, DO NOT EDIT.
package generated

import (
	"context"

	"github.com/jerbob92/wazero-emscripten-embind"
)

type ClassAbstractClass struct {
	embind.ClassBase
}

func (class *ClassAbstractClass) Clone(ctx context.Context) (*ClassAbstractClass, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassAbstractClass), nil
}

func (class *ClassAbstractClass) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassAbstractClass) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassAbstractClass) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassAbstractClass) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassAbstractClass) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassAbstractClass) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassAbstractClass) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassAbstractClass) AbstractMethod(ctx context.Context) (string, error) {
	res, err := class.CallMethod(ctx, "abstractMethod")
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}

func (class *ClassAbstractClass) ConcreteMethod(ctx context.Context) (string, error) {
	res, err := class.CallMethod(ctx, "concreteMethod")
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}

func (class *ClassAbstractClass) OptionalMethod(ctx context.Context, arg0 string) (string, error) {
	res, err := class.CallMethod(ctx, "optionalMethod", arg0)
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}

func (class *ClassAbstractClass) PassShared(ctx context.Context, arg0 embind.ClassBase) error {
	_, err := class.CallMethod(ctx, "passShared", arg0)
	return err
}

func (class *ClassAbstractClass) PassVal(ctx context.Context, arg0 any) error {
	_, err := class.CallMethod(ctx, "passVal", arg0)
	return err
}

func (class *ClassAbstractClass) StaticExtend(ctx context.Context, arg0 string, arg1 any) (any, error) {
	res, err := class.CallInstanceMethod(ctx, nil, "extend", arg0, arg1)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(any), nil
}
func ClassAbstractClassStaticExtend(e embind.Engine, ctx context.Context, arg0 string, arg1 any) (any, error) {
	res, err := e.CallStaticClassMethod(ctx, "AbstractClass", "extend", arg0, arg1)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(any), nil
}

func (class *ClassAbstractClass) StaticImplement(ctx context.Context, arg0 any) (embind.ClassBase, error) {
	res, err := class.CallInstanceMethod(ctx, nil, "implement", arg0)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(embind.ClassBase), nil
}
func ClassAbstractClassStaticImplement(e embind.Engine, ctx context.Context, arg0 any) (embind.ClassBase, error) {
	res, err := e.CallStaticClassMethod(ctx, "AbstractClass", "implement", arg0)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(embind.ClassBase), nil
}

type ClassAbstractClassWithConstructor struct {
	embind.ClassBase
}

func (class *ClassAbstractClassWithConstructor) Clone(ctx context.Context) (*ClassAbstractClassWithConstructor, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassAbstractClassWithConstructor), nil
}

func (class *ClassAbstractClassWithConstructor) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassAbstractClassWithConstructor) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassAbstractClassWithConstructor) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassAbstractClassWithConstructor) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassAbstractClassWithConstructor) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassAbstractClassWithConstructor) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassAbstractClassWithConstructor) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassAbstractClassWithConstructor) AbstractMethod(ctx context.Context) (string, error) {
	res, err := class.CallMethod(ctx, "abstractMethod")
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}

func (class *ClassAbstractClassWithConstructor) ConcreteMethod(ctx context.Context) (string, error) {
	res, err := class.CallMethod(ctx, "concreteMethod")
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}

func (class *ClassAbstractClassWithConstructor) StaticExtend(ctx context.Context, arg0 string, arg1 any) (any, error) {
	res, err := class.CallInstanceMethod(ctx, nil, "extend", arg0, arg1)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(any), nil
}
func ClassAbstractClassWithConstructorStaticExtend(e embind.Engine, ctx context.Context, arg0 string, arg1 any) (any, error) {
	res, err := e.CallStaticClassMethod(ctx, "AbstractClassWithConstructor", "extend", arg0, arg1)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(any), nil
}

func (class *ClassAbstractClassWithConstructor) StaticImplement(ctx context.Context, arg0 any, arg1 string) (embind.ClassBase, error) {
	res, err := class.CallInstanceMethod(ctx, nil, "implement", arg0, arg1)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(embind.ClassBase), nil
}
func ClassAbstractClassWithConstructorStaticImplement(e embind.Engine, ctx context.Context, arg0 any, arg1 string) (embind.ClassBase, error) {
	res, err := e.CallStaticClassMethod(ctx, "AbstractClassWithConstructor", "implement", arg0, arg1)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(embind.ClassBase), nil
}

type ClassAbstractClassWithConstructorWrapper struct {
	embind.ClassBase
}

func (class *ClassAbstractClassWithConstructorWrapper) Clone(ctx context.Context) (*ClassAbstractClassWithConstructorWrapper, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassAbstractClassWithConstructorWrapper), nil
}

func (class *ClassAbstractClassWithConstructorWrapper) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassAbstractClassWithConstructorWrapper) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassAbstractClassWithConstructorWrapper) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassAbstractClassWithConstructorWrapper) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassAbstractClassWithConstructorWrapper) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassAbstractClassWithConstructorWrapper) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassAbstractClassWithConstructorWrapper) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassAbstractClassWithConstructorWrapper) AbstractMethod(ctx context.Context) (string, error) {
	res, err := class.CallMethod(ctx, "abstractMethod")
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}

func (class *ClassAbstractClassWithConstructorWrapper) ConcreteMethod(ctx context.Context) (string, error) {
	res, err := class.CallMethod(ctx, "concreteMethod")
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}

func (class *ClassAbstractClassWithConstructorWrapper) NotifyOnDestruction(ctx context.Context) error {
	_, err := class.CallMethod(ctx, "notifyOnDestruction")
	return err
}

func (class *ClassAbstractClassWithConstructorWrapper) StaticExtend(ctx context.Context, arg0 string, arg1 any) (any, error) {
	res, err := class.CallInstanceMethod(ctx, nil, "extend", arg0, arg1)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(any), nil
}
func ClassAbstractClassWithConstructorWrapperStaticExtend(e embind.Engine, ctx context.Context, arg0 string, arg1 any) (any, error) {
	res, err := e.CallStaticClassMethod(ctx, "AbstractClassWithConstructorWrapper", "extend", arg0, arg1)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(any), nil
}

func (class *ClassAbstractClassWithConstructorWrapper) StaticImplement(ctx context.Context, arg0 any, arg1 string) (embind.ClassBase, error) {
	res, err := class.CallInstanceMethod(ctx, nil, "implement", arg0, arg1)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(embind.ClassBase), nil
}
func ClassAbstractClassWithConstructorWrapperStaticImplement(e embind.Engine, ctx context.Context, arg0 any, arg1 string) (embind.ClassBase, error) {
	res, err := e.CallStaticClassMethod(ctx, "AbstractClassWithConstructorWrapper", "implement", arg0, arg1)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(embind.ClassBase), nil
}

type ClassAbstractClassWrapper struct {
	embind.ClassBase
}

func (class *ClassAbstractClassWrapper) Clone(ctx context.Context) (*ClassAbstractClassWrapper, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassAbstractClassWrapper), nil
}

func (class *ClassAbstractClassWrapper) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassAbstractClassWrapper) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassAbstractClassWrapper) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassAbstractClassWrapper) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassAbstractClassWrapper) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassAbstractClassWrapper) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassAbstractClassWrapper) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassAbstractClassWrapper) AbstractMethod(ctx context.Context) (string, error) {
	res, err := class.CallMethod(ctx, "abstractMethod")
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}

func (class *ClassAbstractClassWrapper) ConcreteMethod(ctx context.Context) (string, error) {
	res, err := class.CallMethod(ctx, "concreteMethod")
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}

func (class *ClassAbstractClassWrapper) NotifyOnDestruction(ctx context.Context) error {
	_, err := class.CallMethod(ctx, "notifyOnDestruction")
	return err
}

func (class *ClassAbstractClassWrapper) OptionalMethod(ctx context.Context, arg0 string) (string, error) {
	res, err := class.CallMethod(ctx, "optionalMethod", arg0)
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}

func (class *ClassAbstractClassWrapper) PassShared(ctx context.Context, arg0 embind.ClassBase) error {
	_, err := class.CallMethod(ctx, "passShared", arg0)
	return err
}

func (class *ClassAbstractClassWrapper) PassVal(ctx context.Context, arg0 any) error {
	_, err := class.CallMethod(ctx, "passVal", arg0)
	return err
}

func (class *ClassAbstractClassWrapper) StaticExtend(ctx context.Context, arg0 string, arg1 any) (any, error) {
	res, err := class.CallInstanceMethod(ctx, nil, "extend", arg0, arg1)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(any), nil
}
func ClassAbstractClassWrapperStaticExtend(e embind.Engine, ctx context.Context, arg0 string, arg1 any) (any, error) {
	res, err := e.CallStaticClassMethod(ctx, "AbstractClassWrapper", "extend", arg0, arg1)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(any), nil
}

func (class *ClassAbstractClassWrapper) StaticImplement(ctx context.Context, arg0 any) (embind.ClassBase, error) {
	res, err := class.CallInstanceMethod(ctx, nil, "implement", arg0)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(embind.ClassBase), nil
}
func ClassAbstractClassWrapperStaticImplement(e embind.Engine, ctx context.Context, arg0 any) (embind.ClassBase, error) {
	res, err := e.CallStaticClassMethod(ctx, "AbstractClassWrapper", "implement", arg0)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(embind.ClassBase), nil
}

type ClassBase struct {
	embind.ClassBase
}

func (class *ClassBase) Clone(ctx context.Context) (*ClassBase, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassBase), nil
}

func (class *ClassBase) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassBase) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassBase) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassBase) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassBase) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassBase) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassBase) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassBase) GetPropertyBaseMember(ctx context.Context) (int32, error) {
	res, err := class.GetProperty(ctx, "baseMember")
	if err != nil {
		return int32(0), err
	}

	if res == nil {
		return int32(0), nil
	}

	return res.(int32), nil
}
func (class *ClassBase) SetPropertyBaseMember(ctx context.Context, val int32) error {
	return class.SetProperty(ctx, "baseMember", val)
}

func (class *ClassBase) GetPropertyMember(ctx context.Context) (int32, error) {
	res, err := class.GetProperty(ctx, "member")
	if err != nil {
		return int32(0), err
	}

	if res == nil {
		return int32(0), nil
	}

	return res.(int32), nil
}
func (class *ClassBase) SetPropertyMember(ctx context.Context, val int32) error {
	return class.SetProperty(ctx, "member", val)
}

func (class *ClassBase) GetBaseMember(ctx context.Context) (int32, error) {
	res, err := class.CallMethod(ctx, "getBaseMember")
	if err != nil {
		return int32(0), err
	}

	if res == nil {
		return int32(0), nil
	}

	return res.(int32), nil
}

func (class *ClassBase) GetClassName(ctx context.Context) (string, error) {
	res, err := class.CallMethod(ctx, "getClassName")
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}

func (class *ClassBase) GetClassNameFromBase(ctx context.Context) (string, error) {
	res, err := class.CallMethod(ctx, "getClassNameFromBase")
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}

func (class *ClassBase) GetClassNameNotAvailableInDerivedClasses(ctx context.Context) (string, error) {
	res, err := class.CallMethod(ctx, "getClassNameNotAvailableInDerivedClasses")
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}

func (class *ClassBase) GetMember(ctx context.Context) (int32, error) {
	res, err := class.CallMethod(ctx, "getMember")
	if err != nil {
		return int32(0), err
	}

	if res == nil {
		return int32(0), nil
	}

	return res.(int32), nil
}

func (class *ClassBase) SetBaseMember(ctx context.Context, arg0 int32) error {
	_, err := class.CallMethod(ctx, "setBaseMember", arg0)
	return err
}

func (class *ClassBase) SetMember(ctx context.Context, arg0 int32) error {
	_, err := class.CallMethod(ctx, "setMember", arg0)
	return err
}

func (class *ClassBase) StaticClassFunction(ctx context.Context) (string, error) {
	res, err := class.CallInstanceMethod(ctx, nil, "classFunction")
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}
func ClassBaseStaticClassFunction(e embind.Engine, ctx context.Context) (string, error) {
	res, err := e.CallStaticClassMethod(ctx, "Base", "classFunction")
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}

func NewClassBase(e embind.Engine, ctx context.Context) (*ClassBase, error) {
	res, err := e.CallPublicSymbol(ctx, "Base")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(*ClassBase), nil
}

type ClassBase1 struct {
	embind.ClassBase
}

func (class *ClassBase1) Clone(ctx context.Context) (*ClassBase1, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassBase1), nil
}

func (class *ClassBase1) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassBase1) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassBase1) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassBase1) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassBase1) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassBase1) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassBase1) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassBase1) GetField(ctx context.Context) (string, error) {
	res, err := class.CallMethod(ctx, "getField")
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}

func NewClassBase1(e embind.Engine, ctx context.Context) (*ClassBase1, error) {
	res, err := e.CallPublicSymbol(ctx, "Base1")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(*ClassBase1), nil
}

type ClassBase2 struct {
	embind.ClassBase
}

func (class *ClassBase2) Clone(ctx context.Context) (*ClassBase2, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassBase2), nil
}

func (class *ClassBase2) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassBase2) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassBase2) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassBase2) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassBase2) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassBase2) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassBase2) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassBase2) GetPropertyField(ctx context.Context) (string, error) {
	res, err := class.GetProperty(ctx, "field")
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}
func (class *ClassBase2) SetPropertyField(ctx context.Context, val string) error {
	return class.SetProperty(ctx, "field", val)
}

func (class *ClassBase2) GetField(ctx context.Context) (string, error) {
	res, err := class.CallMethod(ctx, "getField")
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}

type ClassBaseClass struct {
	embind.ClassBase
}

func (class *ClassBaseClass) Clone(ctx context.Context) (*ClassBaseClass, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassBaseClass), nil
}

func (class *ClassBaseClass) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassBaseClass) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassBaseClass) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassBaseClass) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassBaseClass) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassBaseClass) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassBaseClass) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassBaseClass) Invoke(ctx context.Context, arg0 string) error {
	_, err := class.CallMethod(ctx, "invoke", arg0)
	return err
}

func (class *ClassBaseClass) StaticExtend(ctx context.Context, arg0 string, arg1 any) (any, error) {
	res, err := class.CallInstanceMethod(ctx, nil, "extend", arg0, arg1)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(any), nil
}
func ClassBaseClassStaticExtend(e embind.Engine, ctx context.Context, arg0 string, arg1 any) (any, error) {
	res, err := e.CallStaticClassMethod(ctx, "BaseClass", "extend", arg0, arg1)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(any), nil
}

func (class *ClassBaseClass) StaticImplement(ctx context.Context, arg0 any) (embind.ClassBase, error) {
	res, err := class.CallInstanceMethod(ctx, nil, "implement", arg0)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(embind.ClassBase), nil
}
func ClassBaseClassStaticImplement(e embind.Engine, ctx context.Context, arg0 any) (embind.ClassBase, error) {
	res, err := e.CallStaticClassMethod(ctx, "BaseClass", "implement", arg0)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(embind.ClassBase), nil
}

type ClassBaseClassWrapper struct {
	embind.ClassBase
}

func (class *ClassBaseClassWrapper) Clone(ctx context.Context) (*ClassBaseClassWrapper, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassBaseClassWrapper), nil
}

func (class *ClassBaseClassWrapper) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassBaseClassWrapper) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassBaseClassWrapper) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassBaseClassWrapper) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassBaseClassWrapper) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassBaseClassWrapper) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassBaseClassWrapper) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassBaseClassWrapper) Invoke(ctx context.Context, arg0 string) error {
	_, err := class.CallMethod(ctx, "invoke", arg0)
	return err
}

func (class *ClassBaseClassWrapper) NotifyOnDestruction(ctx context.Context) error {
	_, err := class.CallMethod(ctx, "notifyOnDestruction")
	return err
}

func (class *ClassBaseClassWrapper) StaticExtend(ctx context.Context, arg0 string, arg1 any) (any, error) {
	res, err := class.CallInstanceMethod(ctx, nil, "extend", arg0, arg1)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(any), nil
}
func ClassBaseClassWrapperStaticExtend(e embind.Engine, ctx context.Context, arg0 string, arg1 any) (any, error) {
	res, err := e.CallStaticClassMethod(ctx, "BaseClassWrapper", "extend", arg0, arg1)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(any), nil
}

func (class *ClassBaseClassWrapper) StaticImplement(ctx context.Context, arg0 any) (embind.ClassBase, error) {
	res, err := class.CallInstanceMethod(ctx, nil, "implement", arg0)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(embind.ClassBase), nil
}
func ClassBaseClassWrapperStaticImplement(e embind.Engine, ctx context.Context, arg0 any) (embind.ClassBase, error) {
	res, err := e.CallStaticClassMethod(ctx, "BaseClassWrapper", "implement", arg0)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(embind.ClassBase), nil
}

type ClassBigClass struct {
	embind.ClassBase
}

func (class *ClassBigClass) Clone(ctx context.Context) (*ClassBigClass, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassBigClass), nil
}

func (class *ClassBigClass) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassBigClass) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassBigClass) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassBigClass) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassBigClass) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassBigClass) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassBigClass) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassBigClass) GetPropertyMember(ctx context.Context) (int32, error) {
	res, err := class.GetProperty(ctx, "member")
	if err != nil {
		return int32(0), err
	}

	if res == nil {
		return int32(0), nil
	}

	return res.(int32), nil
}
func (class *ClassBigClass) SetPropertyMember(ctx context.Context, val int32) error {
	return class.SetProperty(ctx, "member", val)
}

func (class *ClassBigClass) GetPropertyOtherMember(ctx context.Context) (int32, error) {
	res, err := class.GetProperty(ctx, "otherMember")
	if err != nil {
		return int32(0), err
	}

	if res == nil {
		return int32(0), nil
	}

	return res.(int32), nil
}
func (class *ClassBigClass) SetPropertyOtherMember(ctx context.Context, val int32) error {
	return class.SetProperty(ctx, "otherMember", val)
}

func (class *ClassBigClass) GetPropertyYetAnotherMember(ctx context.Context) (int32, error) {
	res, err := class.GetProperty(ctx, "yetAnotherMember")
	if err != nil {
		return int32(0), err
	}

	if res == nil {
		return int32(0), nil
	}

	return res.(int32), nil
}
func (class *ClassBigClass) SetPropertyYetAnotherMember(ctx context.Context, val int32) error {
	return class.SetProperty(ctx, "yetAnotherMember", val)
}

func (class *ClassBigClass) GetMember(ctx context.Context) (int32, error) {
	res, err := class.CallMethod(ctx, "getMember")
	if err != nil {
		return int32(0), err
	}

	if res == nil {
		return int32(0), nil
	}

	return res.(int32), nil
}

func NewClassBigClass(e embind.Engine, ctx context.Context) (*ClassBigClass, error) {
	res, err := e.CallPublicSymbol(ctx, "BigClass")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(*ClassBigClass), nil
}

type ClassBoundClass struct {
	embind.ClassBase
}

func (class *ClassBoundClass) Clone(ctx context.Context) (*ClassBoundClass, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassBoundClass), nil
}

func (class *ClassBoundClass) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassBoundClass) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassBoundClass) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassBoundClass) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassBoundClass) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassBoundClass) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassBoundClass) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassBoundClass) GetPropertyProperty(ctx context.Context) (any, error) {
	res, err := class.GetProperty(ctx, "property")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(any), nil
}
func (class *ClassBoundClass) SetPropertyProperty(ctx context.Context, val any) error {
	return class.SetProperty(ctx, "property", val)
}

func (class *ClassBoundClass) Method(ctx context.Context, arg0 any) (any, error) {
	res, err := class.CallMethod(ctx, "method", arg0)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(any), nil
}

func (class *ClassBoundClass) StaticClassfunction(ctx context.Context, arg0 any) (any, error) {
	res, err := class.CallInstanceMethod(ctx, nil, "classfunction", arg0)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(any), nil
}
func ClassBoundClassStaticClassfunction(e embind.Engine, ctx context.Context, arg0 any) (any, error) {
	res, err := e.CallStaticClassMethod(ctx, "BoundClass", "classfunction", arg0)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(any), nil
}

func NewClassBoundClass(e embind.Engine, ctx context.Context) (*ClassBoundClass, error) {
	res, err := e.CallPublicSymbol(ctx, "BoundClass")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(*ClassBoundClass), nil
}

type ClassC struct {
	embind.ClassBase
}

func (class *ClassC) Clone(ctx context.Context) (*ClassC, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassC), nil
}

func (class *ClassC) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassC) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassC) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassC) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassC) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassC) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassC) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func NewClassC(e embind.Engine, ctx context.Context) (*ClassC, error) {
	res, err := e.CallPublicSymbol(ctx, "C")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(*ClassC), nil
}

type ClassCharVector struct {
	embind.ClassBase
}

func (class *ClassCharVector) Clone(ctx context.Context) (*ClassCharVector, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassCharVector), nil
}

func (class *ClassCharVector) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassCharVector) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassCharVector) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassCharVector) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassCharVector) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassCharVector) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassCharVector) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassCharVector) Get(ctx context.Context, arg0 uint32) (any, error) {
	res, err := class.CallMethod(ctx, "get", arg0)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(any), nil
}

func (class *ClassCharVector) Push_back(ctx context.Context, arg0 int8) error {
	_, err := class.CallMethod(ctx, "push_back", arg0)
	return err
}

func (class *ClassCharVector) Resize(ctx context.Context, arg0 uint32, arg1 int8) error {
	_, err := class.CallMethod(ctx, "resize", arg0, arg1)
	return err
}

func (class *ClassCharVector) Set(ctx context.Context, arg0 uint32, arg1 int8) (bool, error) {
	res, err := class.CallMethod(ctx, "set", arg0, arg1)
	if err != nil {
		return bool(false), err
	}

	if res == nil {
		return bool(false), nil
	}

	return res.(bool), nil
}

func (class *ClassCharVector) Size(ctx context.Context) (uint32, error) {
	res, err := class.CallMethod(ctx, "size")
	if err != nil {
		return uint32(0), err
	}

	if res == nil {
		return uint32(0), nil
	}

	return res.(uint32), nil
}

func NewClassCharVector(e embind.Engine, ctx context.Context) (*ClassCharVector, error) {
	res, err := e.CallPublicSymbol(ctx, "CharVector")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(*ClassCharVector), nil
}

type ClassConstAndNonConst struct {
	embind.ClassBase
}

func (class *ClassConstAndNonConst) Clone(ctx context.Context) (*ClassConstAndNonConst, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassConstAndNonConst), nil
}

func (class *ClassConstAndNonConst) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassConstAndNonConst) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassConstAndNonConst) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassConstAndNonConst) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassConstAndNonConst) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassConstAndNonConst) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassConstAndNonConst) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassConstAndNonConst) Method(ctx context.Context) (int32, error) {
	res, err := class.CallMethod(ctx, "method")
	if err != nil {
		return int32(0), err
	}

	if res == nil {
		return int32(0), nil
	}

	return res.(int32), nil
}

type ClassConstructFromFunctionObject struct {
	embind.ClassBase
}

func (class *ClassConstructFromFunctionObject) Clone(ctx context.Context) (*ClassConstructFromFunctionObject, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassConstructFromFunctionObject), nil
}

func (class *ClassConstructFromFunctionObject) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassConstructFromFunctionObject) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassConstructFromFunctionObject) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassConstructFromFunctionObject) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassConstructFromFunctionObject) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassConstructFromFunctionObject) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassConstructFromFunctionObject) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassConstructFromFunctionObject) GetA(ctx context.Context) (int32, error) {
	res, err := class.CallMethod(ctx, "getA")
	if err != nil {
		return int32(0), err
	}

	if res == nil {
		return int32(0), nil
	}

	return res.(int32), nil
}

func (class *ClassConstructFromFunctionObject) GetVal(ctx context.Context) (any, error) {
	res, err := class.CallMethod(ctx, "getVal")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(any), nil
}

func NewClassConstructFromFunctionObject(e embind.Engine, ctx context.Context, arg0 any, arg1 int32) (*ClassConstructFromFunctionObject, error) {
	res, err := e.CallPublicSymbol(ctx, "ConstructFromFunctionObject", arg0, arg1)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(*ClassConstructFromFunctionObject), nil
}

type ClassConstructFromStdFunction struct {
	embind.ClassBase
}

func (class *ClassConstructFromStdFunction) Clone(ctx context.Context) (*ClassConstructFromStdFunction, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassConstructFromStdFunction), nil
}

func (class *ClassConstructFromStdFunction) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassConstructFromStdFunction) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassConstructFromStdFunction) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassConstructFromStdFunction) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassConstructFromStdFunction) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassConstructFromStdFunction) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassConstructFromStdFunction) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassConstructFromStdFunction) GetA(ctx context.Context) (int32, error) {
	res, err := class.CallMethod(ctx, "getA")
	if err != nil {
		return int32(0), err
	}

	if res == nil {
		return int32(0), nil
	}

	return res.(int32), nil
}

func (class *ClassConstructFromStdFunction) GetVal(ctx context.Context) (any, error) {
	res, err := class.CallMethod(ctx, "getVal")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(any), nil
}

func NewClassConstructFromStdFunction(e embind.Engine, ctx context.Context, arg0 any, arg1 int32) (*ClassConstructFromStdFunction, error) {
	res, err := e.CallPublicSymbol(ctx, "ConstructFromStdFunction", arg0, arg1)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(*ClassConstructFromStdFunction), nil
}

type ClassContainsTemplatedMemberClass struct {
	embind.ClassBase
}

func (class *ClassContainsTemplatedMemberClass) Clone(ctx context.Context) (*ClassContainsTemplatedMemberClass, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassContainsTemplatedMemberClass), nil
}

func (class *ClassContainsTemplatedMemberClass) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassContainsTemplatedMemberClass) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassContainsTemplatedMemberClass) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassContainsTemplatedMemberClass) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassContainsTemplatedMemberClass) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassContainsTemplatedMemberClass) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassContainsTemplatedMemberClass) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassContainsTemplatedMemberClass) GetTestTemplate(ctx context.Context) (embind.ClassBase, error) {
	res, err := class.CallMethod(ctx, "getTestTemplate")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(embind.ClassBase), nil
}

func NewClassContainsTemplatedMemberClass(e embind.Engine, ctx context.Context) (*ClassContainsTemplatedMemberClass, error) {
	res, err := e.CallPublicSymbol(ctx, "ContainsTemplatedMemberClass")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(*ClassContainsTemplatedMemberClass), nil
}

type ClassCustomStruct struct {
	embind.ClassBase
}

func (class *ClassCustomStruct) Clone(ctx context.Context) (*ClassCustomStruct, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassCustomStruct), nil
}

func (class *ClassCustomStruct) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassCustomStruct) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassCustomStruct) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassCustomStruct) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassCustomStruct) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassCustomStruct) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassCustomStruct) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassCustomStruct) GetPropertyField(ctx context.Context) (int32, error) {
	res, err := class.GetProperty(ctx, "field")
	if err != nil {
		return int32(0), err
	}

	if res == nil {
		return int32(0), nil
	}

	return res.(int32), nil
}
func (class *ClassCustomStruct) SetPropertyField(ctx context.Context, val int32) error {
	return class.SetProperty(ctx, "field", val)
}

func (class *ClassCustomStruct) GetField(ctx context.Context) (int32, error) {
	res, err := class.CallMethod(ctx, "getField")
	if err != nil {
		return int32(0), err
	}

	if res == nil {
		return int32(0), nil
	}

	return res.(int32), nil
}

func NewClassCustomStruct(e embind.Engine, ctx context.Context) (*ClassCustomStruct, error) {
	res, err := e.CallPublicSymbol(ctx, "CustomStruct")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(*ClassCustomStruct), nil
}

type ClassDerived struct {
	embind.ClassBase
}

func (class *ClassDerived) Clone(ctx context.Context) (*ClassDerived, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassDerived), nil
}

func (class *ClassDerived) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassDerived) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassDerived) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassDerived) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassDerived) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassDerived) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassDerived) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassDerived) GetPropertyBaseMember(ctx context.Context) (int32, error) {
	res, err := class.GetProperty(ctx, "baseMember")
	if err != nil {
		return int32(0), err
	}

	if res == nil {
		return int32(0), nil
	}

	return res.(int32), nil
}
func (class *ClassDerived) SetPropertyBaseMember(ctx context.Context, val int32) error {
	return class.SetProperty(ctx, "baseMember", val)
}

func (class *ClassDerived) GetPropertyMember(ctx context.Context) (int32, error) {
	res, err := class.GetProperty(ctx, "member")
	if err != nil {
		return int32(0), err
	}

	if res == nil {
		return int32(0), nil
	}

	return res.(int32), nil
}
func (class *ClassDerived) SetPropertyMember(ctx context.Context, val int32) error {
	return class.SetProperty(ctx, "member", val)
}

func (class *ClassDerived) GetBaseMember(ctx context.Context) (int32, error) {
	res, err := class.CallMethod(ctx, "getBaseMember")
	if err != nil {
		return int32(0), err
	}

	if res == nil {
		return int32(0), nil
	}

	return res.(int32), nil
}

func (class *ClassDerived) GetClassName(ctx context.Context) (string, error) {
	res, err := class.CallMethod(ctx, "getClassName")
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}

func (class *ClassDerived) GetClassNameFromBase(ctx context.Context) (string, error) {
	res, err := class.CallMethod(ctx, "getClassNameFromBase")
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}

func (class *ClassDerived) GetClassNameNotAvailableInDerivedClasses(ctx context.Context) (string, error) {
	res, err := class.CallMethod(ctx, "getClassNameNotAvailableInDerivedClasses")
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}

func (class *ClassDerived) GetMember(ctx context.Context) (int32, error) {
	res, err := class.CallMethod(ctx, "getMember")
	if err != nil {
		return int32(0), err
	}

	if res == nil {
		return int32(0), nil
	}

	return res.(int32), nil
}

func (class *ClassDerived) SetBaseMember(ctx context.Context, arg0 int32) error {
	_, err := class.CallMethod(ctx, "setBaseMember", arg0)
	return err
}

func (class *ClassDerived) SetMember(ctx context.Context, arg0 int32) error {
	_, err := class.CallMethod(ctx, "setMember", arg0)
	return err
}

func (class *ClassDerived) StaticClassFunction(ctx context.Context) (string, error) {
	res, err := class.CallInstanceMethod(ctx, nil, "classFunction")
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}
func ClassDerivedStaticClassFunction(e embind.Engine, ctx context.Context) (string, error) {
	res, err := e.CallStaticClassMethod(ctx, "Derived", "classFunction")
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}

func NewClassDerived(e embind.Engine, ctx context.Context) (*ClassDerived, error) {
	res, err := e.CallPublicSymbol(ctx, "Derived")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(*ClassDerived), nil
}

type ClassDerivedClass struct {
	embind.ClassBase
}

func (class *ClassDerivedClass) Clone(ctx context.Context) (*ClassDerivedClass, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassDerivedClass), nil
}

func (class *ClassDerivedClass) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassDerivedClass) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassDerivedClass) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassDerivedClass) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassDerivedClass) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassDerivedClass) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassDerivedClass) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassDerivedClass) Invoke(ctx context.Context, arg0 string) error {
	_, err := class.CallMethod(ctx, "invoke", arg0)
	return err
}

func (class *ClassDerivedClass) StaticExtend(ctx context.Context, arg0 string, arg1 any) (any, error) {
	res, err := class.CallInstanceMethod(ctx, nil, "extend", arg0, arg1)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(any), nil
}
func ClassDerivedClassStaticExtend(e embind.Engine, ctx context.Context, arg0 string, arg1 any) (any, error) {
	res, err := e.CallStaticClassMethod(ctx, "DerivedClass", "extend", arg0, arg1)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(any), nil
}

func (class *ClassDerivedClass) StaticImplement(ctx context.Context, arg0 any) (embind.ClassBase, error) {
	res, err := class.CallInstanceMethod(ctx, nil, "implement", arg0)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(embind.ClassBase), nil
}
func ClassDerivedClassStaticImplement(e embind.Engine, ctx context.Context, arg0 any) (embind.ClassBase, error) {
	res, err := e.CallStaticClassMethod(ctx, "DerivedClass", "implement", arg0)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(embind.ClassBase), nil
}

type ClassDerivedHolder struct {
	embind.ClassBase
}

func (class *ClassDerivedHolder) Clone(ctx context.Context) (*ClassDerivedHolder, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassDerivedHolder), nil
}

func (class *ClassDerivedHolder) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassDerivedHolder) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassDerivedHolder) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassDerivedHolder) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassDerivedHolder) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassDerivedHolder) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassDerivedHolder) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassDerivedHolder) DeleteDerived(ctx context.Context) error {
	_, err := class.CallMethod(ctx, "deleteDerived")
	return err
}

func (class *ClassDerivedHolder) GetDerived(ctx context.Context) (embind.ClassBase, error) {
	res, err := class.CallMethod(ctx, "getDerived")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(embind.ClassBase), nil
}

func (class *ClassDerivedHolder) GetDerivedClassName(ctx context.Context) (string, error) {
	res, err := class.CallMethod(ctx, "getDerivedClassName")
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}

func (class *ClassDerivedHolder) NewDerived(ctx context.Context) error {
	_, err := class.CallMethod(ctx, "newDerived")
	return err
}

func NewClassDerivedHolder(e embind.Engine, ctx context.Context) (*ClassDerivedHolder, error) {
	res, err := e.CallPublicSymbol(ctx, "DerivedHolder")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(*ClassDerivedHolder), nil
}

type ClassDerivedThrice struct {
	embind.ClassBase
}

func (class *ClassDerivedThrice) Clone(ctx context.Context) (*ClassDerivedThrice, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassDerivedThrice), nil
}

func (class *ClassDerivedThrice) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassDerivedThrice) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassDerivedThrice) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassDerivedThrice) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassDerivedThrice) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassDerivedThrice) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassDerivedThrice) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassDerivedThrice) GetPropertyBaseMember(ctx context.Context) (int32, error) {
	res, err := class.GetProperty(ctx, "baseMember")
	if err != nil {
		return int32(0), err
	}

	if res == nil {
		return int32(0), nil
	}

	return res.(int32), nil
}
func (class *ClassDerivedThrice) SetPropertyBaseMember(ctx context.Context, val int32) error {
	return class.SetProperty(ctx, "baseMember", val)
}

func (class *ClassDerivedThrice) GetPropertyMember(ctx context.Context) (int32, error) {
	res, err := class.GetProperty(ctx, "member")
	if err != nil {
		return int32(0), err
	}

	if res == nil {
		return int32(0), nil
	}

	return res.(int32), nil
}
func (class *ClassDerivedThrice) SetPropertyMember(ctx context.Context, val int32) error {
	return class.SetProperty(ctx, "member", val)
}

func (class *ClassDerivedThrice) GetBaseMember(ctx context.Context) (int32, error) {
	res, err := class.CallMethod(ctx, "getBaseMember")
	if err != nil {
		return int32(0), err
	}

	if res == nil {
		return int32(0), nil
	}

	return res.(int32), nil
}

func (class *ClassDerivedThrice) GetClassName(ctx context.Context) (string, error) {
	res, err := class.CallMethod(ctx, "getClassName")
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}

func (class *ClassDerivedThrice) GetClassNameFromBase(ctx context.Context) (string, error) {
	res, err := class.CallMethod(ctx, "getClassNameFromBase")
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}

func (class *ClassDerivedThrice) GetClassNameNotAvailableInDerivedClasses(ctx context.Context) (string, error) {
	res, err := class.CallMethod(ctx, "getClassNameNotAvailableInDerivedClasses")
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}

func (class *ClassDerivedThrice) GetMember(ctx context.Context) (int32, error) {
	res, err := class.CallMethod(ctx, "getMember")
	if err != nil {
		return int32(0), err
	}

	if res == nil {
		return int32(0), nil
	}

	return res.(int32), nil
}

func (class *ClassDerivedThrice) SetBaseMember(ctx context.Context, arg0 int32) error {
	_, err := class.CallMethod(ctx, "setBaseMember", arg0)
	return err
}

func (class *ClassDerivedThrice) SetMember(ctx context.Context, arg0 int32) error {
	_, err := class.CallMethod(ctx, "setMember", arg0)
	return err
}

func (class *ClassDerivedThrice) StaticClassFunction(ctx context.Context) (string, error) {
	res, err := class.CallInstanceMethod(ctx, nil, "classFunction")
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}
func ClassDerivedThriceStaticClassFunction(e embind.Engine, ctx context.Context) (string, error) {
	res, err := e.CallStaticClassMethod(ctx, "DerivedThrice", "classFunction")
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}

func NewClassDerivedThrice(e embind.Engine, ctx context.Context) (*ClassDerivedThrice, error) {
	res, err := e.CallPublicSymbol(ctx, "DerivedThrice")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(*ClassDerivedThrice), nil
}

type ClassDerivedTwice struct {
	embind.ClassBase
}

func (class *ClassDerivedTwice) Clone(ctx context.Context) (*ClassDerivedTwice, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassDerivedTwice), nil
}

func (class *ClassDerivedTwice) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassDerivedTwice) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassDerivedTwice) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassDerivedTwice) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassDerivedTwice) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassDerivedTwice) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassDerivedTwice) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassDerivedTwice) GetPropertyBaseMember(ctx context.Context) (int32, error) {
	res, err := class.GetProperty(ctx, "baseMember")
	if err != nil {
		return int32(0), err
	}

	if res == nil {
		return int32(0), nil
	}

	return res.(int32), nil
}
func (class *ClassDerivedTwice) SetPropertyBaseMember(ctx context.Context, val int32) error {
	return class.SetProperty(ctx, "baseMember", val)
}

func (class *ClassDerivedTwice) GetPropertyMember(ctx context.Context) (int32, error) {
	res, err := class.GetProperty(ctx, "member")
	if err != nil {
		return int32(0), err
	}

	if res == nil {
		return int32(0), nil
	}

	return res.(int32), nil
}
func (class *ClassDerivedTwice) SetPropertyMember(ctx context.Context, val int32) error {
	return class.SetProperty(ctx, "member", val)
}

func (class *ClassDerivedTwice) GetBaseMember(ctx context.Context) (int32, error) {
	res, err := class.CallMethod(ctx, "getBaseMember")
	if err != nil {
		return int32(0), err
	}

	if res == nil {
		return int32(0), nil
	}

	return res.(int32), nil
}

func (class *ClassDerivedTwice) GetClassName(ctx context.Context) (string, error) {
	res, err := class.CallMethod(ctx, "getClassName")
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}

func (class *ClassDerivedTwice) GetClassNameFromBase(ctx context.Context) (string, error) {
	res, err := class.CallMethod(ctx, "getClassNameFromBase")
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}

func (class *ClassDerivedTwice) GetClassNameNotAvailableInDerivedClasses(ctx context.Context) (string, error) {
	res, err := class.CallMethod(ctx, "getClassNameNotAvailableInDerivedClasses")
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}

func (class *ClassDerivedTwice) GetMember(ctx context.Context) (int32, error) {
	res, err := class.CallMethod(ctx, "getMember")
	if err != nil {
		return int32(0), err
	}

	if res == nil {
		return int32(0), nil
	}

	return res.(int32), nil
}

func (class *ClassDerivedTwice) SetBaseMember(ctx context.Context, arg0 int32) error {
	_, err := class.CallMethod(ctx, "setBaseMember", arg0)
	return err
}

func (class *ClassDerivedTwice) SetMember(ctx context.Context, arg0 int32) error {
	_, err := class.CallMethod(ctx, "setMember", arg0)
	return err
}

func (class *ClassDerivedTwice) StaticClassFunction(ctx context.Context) (string, error) {
	res, err := class.CallInstanceMethod(ctx, nil, "classFunction")
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}
func ClassDerivedTwiceStaticClassFunction(e embind.Engine, ctx context.Context) (string, error) {
	res, err := e.CallStaticClassMethod(ctx, "DerivedTwice", "classFunction")
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}

func NewClassDerivedTwice(e embind.Engine, ctx context.Context) (*ClassDerivedTwice, error) {
	res, err := e.CallPublicSymbol(ctx, "DerivedTwice")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(*ClassDerivedTwice), nil
}

type ClassDerivedWithMixin struct {
	embind.ClassBase
}

func (class *ClassDerivedWithMixin) Clone(ctx context.Context) (*ClassDerivedWithMixin, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassDerivedWithMixin), nil
}

func (class *ClassDerivedWithMixin) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassDerivedWithMixin) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassDerivedWithMixin) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassDerivedWithMixin) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassDerivedWithMixin) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassDerivedWithMixin) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassDerivedWithMixin) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassDerivedWithMixin) GetPropertyBaseMember(ctx context.Context) (int32, error) {
	res, err := class.GetProperty(ctx, "baseMember")
	if err != nil {
		return int32(0), err
	}

	if res == nil {
		return int32(0), nil
	}

	return res.(int32), nil
}
func (class *ClassDerivedWithMixin) SetPropertyBaseMember(ctx context.Context, val int32) error {
	return class.SetProperty(ctx, "baseMember", val)
}

func (class *ClassDerivedWithMixin) GetPropertyMember(ctx context.Context) (int32, error) {
	res, err := class.GetProperty(ctx, "member")
	if err != nil {
		return int32(0), err
	}

	if res == nil {
		return int32(0), nil
	}

	return res.(int32), nil
}
func (class *ClassDerivedWithMixin) SetPropertyMember(ctx context.Context, val int32) error {
	return class.SetProperty(ctx, "member", val)
}

func (class *ClassDerivedWithMixin) Get10(ctx context.Context) (int32, error) {
	res, err := class.CallMethod(ctx, "get10")
	if err != nil {
		return int32(0), err
	}

	if res == nil {
		return int32(0), nil
	}

	return res.(int32), nil
}

func (class *ClassDerivedWithMixin) GetBaseMember(ctx context.Context) (int32, error) {
	res, err := class.CallMethod(ctx, "getBaseMember")
	if err != nil {
		return int32(0), err
	}

	if res == nil {
		return int32(0), nil
	}

	return res.(int32), nil
}

func (class *ClassDerivedWithMixin) GetClassName(ctx context.Context) (string, error) {
	res, err := class.CallMethod(ctx, "getClassName")
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}

func (class *ClassDerivedWithMixin) GetClassNameFromBase(ctx context.Context) (string, error) {
	res, err := class.CallMethod(ctx, "getClassNameFromBase")
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}

func (class *ClassDerivedWithMixin) GetClassNameNotAvailableInDerivedClasses(ctx context.Context) (string, error) {
	res, err := class.CallMethod(ctx, "getClassNameNotAvailableInDerivedClasses")
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}

func (class *ClassDerivedWithMixin) GetMember(ctx context.Context) (int32, error) {
	res, err := class.CallMethod(ctx, "getMember")
	if err != nil {
		return int32(0), err
	}

	if res == nil {
		return int32(0), nil
	}

	return res.(int32), nil
}

func (class *ClassDerivedWithMixin) SetBaseMember(ctx context.Context, arg0 int32) error {
	_, err := class.CallMethod(ctx, "setBaseMember", arg0)
	return err
}

func (class *ClassDerivedWithMixin) SetMember(ctx context.Context, arg0 int32) error {
	_, err := class.CallMethod(ctx, "setMember", arg0)
	return err
}

func (class *ClassDerivedWithMixin) StaticClassFunction(ctx context.Context) (string, error) {
	res, err := class.CallInstanceMethod(ctx, nil, "classFunction")
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}
func ClassDerivedWithMixinStaticClassFunction(e embind.Engine, ctx context.Context) (string, error) {
	res, err := e.CallStaticClassMethod(ctx, "DerivedWithMixin", "classFunction")
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}

func NewClassDerivedWithMixin(e embind.Engine, ctx context.Context) (*ClassDerivedWithMixin, error) {
	res, err := e.CallPublicSymbol(ctx, "DerivedWithMixin")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(*ClassDerivedWithMixin), nil
}

type ClassDerivedWithOffset struct {
	embind.ClassBase
}

func (class *ClassDerivedWithOffset) Clone(ctx context.Context) (*ClassDerivedWithOffset, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassDerivedWithOffset), nil
}

func (class *ClassDerivedWithOffset) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassDerivedWithOffset) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassDerivedWithOffset) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassDerivedWithOffset) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassDerivedWithOffset) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassDerivedWithOffset) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassDerivedWithOffset) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassDerivedWithOffset) GetPropertyBaseMember(ctx context.Context) (int32, error) {
	res, err := class.GetProperty(ctx, "baseMember")
	if err != nil {
		return int32(0), err
	}

	if res == nil {
		return int32(0), nil
	}

	return res.(int32), nil
}
func (class *ClassDerivedWithOffset) SetPropertyBaseMember(ctx context.Context, val int32) error {
	return class.SetProperty(ctx, "baseMember", val)
}

func (class *ClassDerivedWithOffset) GetPropertyMember(ctx context.Context) (int32, error) {
	res, err := class.GetProperty(ctx, "member")
	if err != nil {
		return int32(0), err
	}

	if res == nil {
		return int32(0), nil
	}

	return res.(int32), nil
}
func (class *ClassDerivedWithOffset) SetPropertyMember(ctx context.Context, val int32) error {
	return class.SetProperty(ctx, "member", val)
}

func (class *ClassDerivedWithOffset) GetBaseMember(ctx context.Context) (int32, error) {
	res, err := class.CallMethod(ctx, "getBaseMember")
	if err != nil {
		return int32(0), err
	}

	if res == nil {
		return int32(0), nil
	}

	return res.(int32), nil
}

func (class *ClassDerivedWithOffset) GetClassName(ctx context.Context) (string, error) {
	res, err := class.CallMethod(ctx, "getClassName")
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}

func (class *ClassDerivedWithOffset) GetClassNameFromBase(ctx context.Context) (string, error) {
	res, err := class.CallMethod(ctx, "getClassNameFromBase")
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}

func (class *ClassDerivedWithOffset) GetClassNameNotAvailableInDerivedClasses(ctx context.Context) (string, error) {
	res, err := class.CallMethod(ctx, "getClassNameNotAvailableInDerivedClasses")
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}

func (class *ClassDerivedWithOffset) GetMember(ctx context.Context) (int32, error) {
	res, err := class.CallMethod(ctx, "getMember")
	if err != nil {
		return int32(0), err
	}

	if res == nil {
		return int32(0), nil
	}

	return res.(int32), nil
}

func (class *ClassDerivedWithOffset) SetBaseMember(ctx context.Context, arg0 int32) error {
	_, err := class.CallMethod(ctx, "setBaseMember", arg0)
	return err
}

func (class *ClassDerivedWithOffset) SetMember(ctx context.Context, arg0 int32) error {
	_, err := class.CallMethod(ctx, "setMember", arg0)
	return err
}

func (class *ClassDerivedWithOffset) StaticClassFunction(ctx context.Context) (string, error) {
	res, err := class.CallInstanceMethod(ctx, nil, "classFunction")
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}
func ClassDerivedWithOffsetStaticClassFunction(e embind.Engine, ctx context.Context) (string, error) {
	res, err := e.CallStaticClassMethod(ctx, "DerivedWithOffset", "classFunction")
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}

func NewClassDerivedWithOffset(e embind.Engine, ctx context.Context) (*ClassDerivedWithOffset, error) {
	res, err := e.CallPublicSymbol(ctx, "DerivedWithOffset")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(*ClassDerivedWithOffset), nil
}

type ClassDummyForOverloads struct {
	embind.ClassBase
}

func (class *ClassDummyForOverloads) Clone(ctx context.Context) (*ClassDummyForOverloads, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassDummyForOverloads), nil
}

func (class *ClassDummyForOverloads) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassDummyForOverloads) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassDummyForOverloads) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassDummyForOverloads) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassDummyForOverloads) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassDummyForOverloads) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassDummyForOverloads) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func NewClassDummyForOverloads(e embind.Engine, ctx context.Context) (*ClassDummyForOverloads, error) {
	res, err := e.CallPublicSymbol(ctx, "DummyForOverloads")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(*ClassDummyForOverloads), nil
}

type ClassDummyForPointer struct {
	embind.ClassBase
}

func (class *ClassDummyForPointer) Clone(ctx context.Context) (*ClassDummyForPointer, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassDummyForPointer), nil
}

func (class *ClassDummyForPointer) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassDummyForPointer) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassDummyForPointer) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassDummyForPointer) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassDummyForPointer) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassDummyForPointer) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassDummyForPointer) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

type ClassEmValVector struct {
	embind.ClassBase
}

func (class *ClassEmValVector) Clone(ctx context.Context) (*ClassEmValVector, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassEmValVector), nil
}

func (class *ClassEmValVector) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassEmValVector) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassEmValVector) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassEmValVector) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassEmValVector) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassEmValVector) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassEmValVector) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassEmValVector) Get(ctx context.Context, arg0 uint32) (any, error) {
	res, err := class.CallMethod(ctx, "get", arg0)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(any), nil
}

func (class *ClassEmValVector) Push_back(ctx context.Context, arg0 any) error {
	_, err := class.CallMethod(ctx, "push_back", arg0)
	return err
}

func (class *ClassEmValVector) Resize(ctx context.Context, arg0 uint32, arg1 any) error {
	_, err := class.CallMethod(ctx, "resize", arg0, arg1)
	return err
}

func (class *ClassEmValVector) Set(ctx context.Context, arg0 uint32, arg1 any) (bool, error) {
	res, err := class.CallMethod(ctx, "set", arg0, arg1)
	if err != nil {
		return bool(false), err
	}

	if res == nil {
		return bool(false), nil
	}

	return res.(bool), nil
}

func (class *ClassEmValVector) Size(ctx context.Context) (uint32, error) {
	res, err := class.CallMethod(ctx, "size")
	if err != nil {
		return uint32(0), err
	}

	if res == nil {
		return uint32(0), nil
	}

	return res.(uint32), nil
}

func NewClassEmValVector(e embind.Engine, ctx context.Context) (*ClassEmValVector, error) {
	res, err := e.CallPublicSymbol(ctx, "EmValVector")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(*ClassEmValVector), nil
}

type ClassFirstElement struct {
	embind.ClassBase
}

func (class *ClassFirstElement) Clone(ctx context.Context) (*ClassFirstElement, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassFirstElement), nil
}

func (class *ClassFirstElement) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassFirstElement) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassFirstElement) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassFirstElement) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassFirstElement) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassFirstElement) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassFirstElement) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

type ClassFloatVector struct {
	embind.ClassBase
}

func (class *ClassFloatVector) Clone(ctx context.Context) (*ClassFloatVector, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassFloatVector), nil
}

func (class *ClassFloatVector) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassFloatVector) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassFloatVector) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassFloatVector) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassFloatVector) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassFloatVector) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassFloatVector) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassFloatVector) Get(ctx context.Context, arg0 uint32) (any, error) {
	res, err := class.CallMethod(ctx, "get", arg0)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(any), nil
}

func (class *ClassFloatVector) Push_back(ctx context.Context, arg0 float32) error {
	_, err := class.CallMethod(ctx, "push_back", arg0)
	return err
}

func (class *ClassFloatVector) Resize(ctx context.Context, arg0 uint32, arg1 float32) error {
	_, err := class.CallMethod(ctx, "resize", arg0, arg1)
	return err
}

func (class *ClassFloatVector) Set(ctx context.Context, arg0 uint32, arg1 float32) (bool, error) {
	res, err := class.CallMethod(ctx, "set", arg0, arg1)
	if err != nil {
		return bool(false), err
	}

	if res == nil {
		return bool(false), nil
	}

	return res.(bool), nil
}

func (class *ClassFloatVector) Size(ctx context.Context) (uint32, error) {
	res, err := class.CallMethod(ctx, "size")
	if err != nil {
		return uint32(0), err
	}

	if res == nil {
		return uint32(0), nil
	}

	return res.(uint32), nil
}

func NewClassFloatVector(e embind.Engine, ctx context.Context) (*ClassFloatVector, error) {
	res, err := e.CallPublicSymbol(ctx, "FloatVector")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(*ClassFloatVector), nil
}

type ClassFoo struct {
	embind.ClassBase
}

func (class *ClassFoo) Clone(ctx context.Context) (*ClassFoo, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassFoo), nil
}

func (class *ClassFoo) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassFoo) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassFoo) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassFoo) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassFoo) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassFoo) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassFoo) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func NewClassFoo(e embind.Engine, ctx context.Context, arg0 string) (*ClassFoo, error) {
	res, err := e.CallPublicSymbol(ctx, "Foo", arg0)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(*ClassFoo), nil
}

type ClassHasConstructorUsingUnboundArgument struct {
	embind.ClassBase
}

func (class *ClassHasConstructorUsingUnboundArgument) Clone(ctx context.Context) (*ClassHasConstructorUsingUnboundArgument, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassHasConstructorUsingUnboundArgument), nil
}

func (class *ClassHasConstructorUsingUnboundArgument) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassHasConstructorUsingUnboundArgument) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassHasConstructorUsingUnboundArgument) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassHasConstructorUsingUnboundArgument) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassHasConstructorUsingUnboundArgument) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassHasConstructorUsingUnboundArgument) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassHasConstructorUsingUnboundArgument) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func NewClassHasConstructorUsingUnboundArgument(e embind.Engine, ctx context.Context, arg0 any) (*ClassHasConstructorUsingUnboundArgument, error) {
	res, err := e.CallPublicSymbol(ctx, "HasConstructorUsingUnboundArgument", arg0)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(*ClassHasConstructorUsingUnboundArgument), nil
}

type ClassHasExternalConstructor struct {
	embind.ClassBase
}

func (class *ClassHasExternalConstructor) Clone(ctx context.Context) (*ClassHasExternalConstructor, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassHasExternalConstructor), nil
}

func (class *ClassHasExternalConstructor) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassHasExternalConstructor) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassHasExternalConstructor) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassHasExternalConstructor) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassHasExternalConstructor) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassHasExternalConstructor) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassHasExternalConstructor) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassHasExternalConstructor) GetString(ctx context.Context) (string, error) {
	res, err := class.CallMethod(ctx, "getString")
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}

func NewClassHasExternalConstructor(e embind.Engine, ctx context.Context, arg0 string) (*ClassHasExternalConstructor, error) {
	res, err := e.CallPublicSymbol(ctx, "HasExternalConstructor", arg0)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(*ClassHasExternalConstructor), nil
}

type ClassHasReadOnlyProperty struct {
	embind.ClassBase
}

func (class *ClassHasReadOnlyProperty) Clone(ctx context.Context) (*ClassHasReadOnlyProperty, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassHasReadOnlyProperty), nil
}

func (class *ClassHasReadOnlyProperty) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassHasReadOnlyProperty) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassHasReadOnlyProperty) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassHasReadOnlyProperty) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassHasReadOnlyProperty) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassHasReadOnlyProperty) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassHasReadOnlyProperty) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassHasReadOnlyProperty) GetPropertyI(ctx context.Context) (int32, error) {
	res, err := class.GetProperty(ctx, "i")
	if err != nil {
		return int32(0), err
	}

	if res == nil {
		return int32(0), nil
	}

	return res.(int32), nil
}

func NewClassHasReadOnlyProperty(e embind.Engine, ctx context.Context, arg0 int32) (*ClassHasReadOnlyProperty, error) {
	res, err := e.CallPublicSymbol(ctx, "HasReadOnlyProperty", arg0)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(*ClassHasReadOnlyProperty), nil
}

type ClassHasStaticMember struct {
	embind.ClassBase
}

func (class *ClassHasStaticMember) Clone(ctx context.Context) (*ClassHasStaticMember, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassHasStaticMember), nil
}

func (class *ClassHasStaticMember) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassHasStaticMember) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassHasStaticMember) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassHasStaticMember) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassHasStaticMember) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassHasStaticMember) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassHasStaticMember) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassHasStaticMember) GetStaticPropertyC(ctx context.Context) (int32, error) {
	res, err := class.GetInstanceProperty(ctx, nil, "c")
	if err != nil {
		return int32(0), err
	}

	if res == nil {
		return int32(0), nil
	}

	return res.(int32), nil
}
func ClassHasStaticMemberGetStaticPropertyC(e embind.Engine, ctx context.Context) (int32, error) {
	res, err := e.GetStaticClassProperty(ctx, "HasStaticMember", "c")
	if err != nil {
		return int32(0), err
	}

	if res == nil {
		return int32(0), nil
	}

	return res.(int32), nil
}

func (class *ClassHasStaticMember) GetStaticPropertyV(ctx context.Context) (int32, error) {
	res, err := class.GetInstanceProperty(ctx, nil, "v")
	if err != nil {
		return int32(0), err
	}

	if res == nil {
		return int32(0), nil
	}

	return res.(int32), nil
}
func ClassHasStaticMemberGetStaticPropertyV(e embind.Engine, ctx context.Context) (int32, error) {
	res, err := e.GetStaticClassProperty(ctx, "HasStaticMember", "v")
	if err != nil {
		return int32(0), err
	}

	if res == nil {
		return int32(0), nil
	}

	return res.(int32), nil
}
func (class *ClassHasStaticMember) SetStaticPropertyV(ctx context.Context, val int32) error {
	return class.SetInstanceProperty(ctx, nil, "v", val)
}
func ClassHasStaticMemberSetStaticPropertyV(e embind.Engine, ctx context.Context, val int32) error {
	return e.SetStaticClassProperty(ctx, "HasStaticMember", "v", val)
}

type ClassHasTwoBases struct {
	embind.ClassBase
}

func (class *ClassHasTwoBases) Clone(ctx context.Context) (*ClassHasTwoBases, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassHasTwoBases), nil
}

func (class *ClassHasTwoBases) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassHasTwoBases) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassHasTwoBases) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassHasTwoBases) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassHasTwoBases) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassHasTwoBases) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassHasTwoBases) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassHasTwoBases) GetPropertyField(ctx context.Context) (string, error) {
	res, err := class.GetProperty(ctx, "field")
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}
func (class *ClassHasTwoBases) SetPropertyField(ctx context.Context, val string) error {
	return class.SetProperty(ctx, "field", val)
}

func (class *ClassHasTwoBases) GetField(ctx context.Context) (string, error) {
	res, err := class.CallMethod(ctx, "getField")
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}

func NewClassHasTwoBases(e embind.Engine, ctx context.Context) (*ClassHasTwoBases, error) {
	res, err := e.CallPublicSymbol(ctx, "HasTwoBases")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(*ClassHasTwoBases), nil
}

type ClassHeldAbstractClass struct {
	embind.ClassBase
}

func (class *ClassHeldAbstractClass) Clone(ctx context.Context) (*ClassHeldAbstractClass, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassHeldAbstractClass), nil
}

func (class *ClassHeldAbstractClass) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassHeldAbstractClass) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassHeldAbstractClass) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassHeldAbstractClass) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassHeldAbstractClass) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassHeldAbstractClass) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassHeldAbstractClass) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassHeldAbstractClass) GetClassName(ctx context.Context) (string, error) {
	res, err := class.CallMethod(ctx, "getClassName")
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}

func (class *ClassHeldAbstractClass) Method(ctx context.Context) error {
	_, err := class.CallMethod(ctx, "method")
	return err
}

func (class *ClassHeldAbstractClass) StaticExtend(ctx context.Context, arg0 string, arg1 any) (any, error) {
	res, err := class.CallInstanceMethod(ctx, nil, "extend", arg0, arg1)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(any), nil
}
func ClassHeldAbstractClassStaticExtend(e embind.Engine, ctx context.Context, arg0 string, arg1 any) (any, error) {
	res, err := e.CallStaticClassMethod(ctx, "HeldAbstractClass", "extend", arg0, arg1)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(any), nil
}

func (class *ClassHeldAbstractClass) StaticImplement(ctx context.Context, arg0 any) (embind.ClassBase, error) {
	res, err := class.CallInstanceMethod(ctx, nil, "implement", arg0)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(embind.ClassBase), nil
}
func ClassHeldAbstractClassStaticImplement(e embind.Engine, ctx context.Context, arg0 any) (embind.ClassBase, error) {
	res, err := e.CallStaticClassMethod(ctx, "HeldAbstractClass", "implement", arg0)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(embind.ClassBase), nil
}

type ClassHeldAbstractClassWrapper struct {
	embind.ClassBase
}

func (class *ClassHeldAbstractClassWrapper) Clone(ctx context.Context) (*ClassHeldAbstractClassWrapper, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassHeldAbstractClassWrapper), nil
}

func (class *ClassHeldAbstractClassWrapper) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassHeldAbstractClassWrapper) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassHeldAbstractClassWrapper) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassHeldAbstractClassWrapper) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassHeldAbstractClassWrapper) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassHeldAbstractClassWrapper) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassHeldAbstractClassWrapper) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassHeldAbstractClassWrapper) GetClassName(ctx context.Context) (string, error) {
	res, err := class.CallMethod(ctx, "getClassName")
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}

func (class *ClassHeldAbstractClassWrapper) Method(ctx context.Context) error {
	_, err := class.CallMethod(ctx, "method")
	return err
}

func (class *ClassHeldAbstractClassWrapper) NotifyOnDestruction(ctx context.Context) error {
	_, err := class.CallMethod(ctx, "notifyOnDestruction")
	return err
}

func (class *ClassHeldAbstractClassWrapper) StaticExtend(ctx context.Context, arg0 string, arg1 any) (any, error) {
	res, err := class.CallInstanceMethod(ctx, nil, "extend", arg0, arg1)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(any), nil
}
func ClassHeldAbstractClassWrapperStaticExtend(e embind.Engine, ctx context.Context, arg0 string, arg1 any) (any, error) {
	res, err := e.CallStaticClassMethod(ctx, "HeldAbstractClassWrapper", "extend", arg0, arg1)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(any), nil
}

func (class *ClassHeldAbstractClassWrapper) StaticImplement(ctx context.Context, arg0 any) (embind.ClassBase, error) {
	res, err := class.CallInstanceMethod(ctx, nil, "implement", arg0)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(embind.ClassBase), nil
}
func ClassHeldAbstractClassWrapperStaticImplement(e embind.Engine, ctx context.Context, arg0 any) (embind.ClassBase, error) {
	res, err := e.CallStaticClassMethod(ctx, "HeldAbstractClassWrapper", "implement", arg0)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(embind.ClassBase), nil
}

type ClassHeldByCustomSmartPtr struct {
	embind.ClassBase
}

func (class *ClassHeldByCustomSmartPtr) Clone(ctx context.Context) (*ClassHeldByCustomSmartPtr, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassHeldByCustomSmartPtr), nil
}

func (class *ClassHeldByCustomSmartPtr) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassHeldByCustomSmartPtr) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassHeldByCustomSmartPtr) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassHeldByCustomSmartPtr) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassHeldByCustomSmartPtr) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassHeldByCustomSmartPtr) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassHeldByCustomSmartPtr) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassHeldByCustomSmartPtr) GetPropertyI(ctx context.Context) (int32, error) {
	res, err := class.GetProperty(ctx, "i")
	if err != nil {
		return int32(0), err
	}

	if res == nil {
		return int32(0), nil
	}

	return res.(int32), nil
}
func (class *ClassHeldByCustomSmartPtr) SetPropertyI(ctx context.Context, val int32) error {
	return class.SetProperty(ctx, "i", val)
}

func (class *ClassHeldByCustomSmartPtr) GetPropertyS(ctx context.Context) (string, error) {
	res, err := class.GetProperty(ctx, "s")
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}
func (class *ClassHeldByCustomSmartPtr) SetPropertyS(ctx context.Context, val string) error {
	return class.SetProperty(ctx, "s", val)
}

func (class *ClassHeldByCustomSmartPtr) StaticCreateSharedPtr(ctx context.Context, arg0 int32, arg1 string) (embind.ClassBase, error) {
	res, err := class.CallInstanceMethod(ctx, nil, "createSharedPtr", arg0, arg1)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(embind.ClassBase), nil
}
func ClassHeldByCustomSmartPtrStaticCreateSharedPtr(e embind.Engine, ctx context.Context, arg0 int32, arg1 string) (embind.ClassBase, error) {
	res, err := e.CallStaticClassMethod(ctx, "HeldByCustomSmartPtr", "createSharedPtr", arg0, arg1)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(embind.ClassBase), nil
}

func NewClassHeldByCustomSmartPtr(e embind.Engine, ctx context.Context, arg0 int32, arg1 string) (*ClassHeldByCustomSmartPtr, error) {
	res, err := e.CallPublicSymbol(ctx, "HeldByCustomSmartPtr", arg0, arg1)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(*ClassHeldByCustomSmartPtr), nil
}

type ClassHeldBySmartPtr struct {
	embind.ClassBase
}

func (class *ClassHeldBySmartPtr) Clone(ctx context.Context) (*ClassHeldBySmartPtr, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassHeldBySmartPtr), nil
}

func (class *ClassHeldBySmartPtr) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassHeldBySmartPtr) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassHeldBySmartPtr) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassHeldBySmartPtr) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassHeldBySmartPtr) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassHeldBySmartPtr) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassHeldBySmartPtr) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassHeldBySmartPtr) GetPropertyI(ctx context.Context) (int32, error) {
	res, err := class.GetProperty(ctx, "i")
	if err != nil {
		return int32(0), err
	}

	if res == nil {
		return int32(0), nil
	}

	return res.(int32), nil
}
func (class *ClassHeldBySmartPtr) SetPropertyI(ctx context.Context, val int32) error {
	return class.SetProperty(ctx, "i", val)
}

func (class *ClassHeldBySmartPtr) GetPropertyS(ctx context.Context) (string, error) {
	res, err := class.GetProperty(ctx, "s")
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}
func (class *ClassHeldBySmartPtr) SetPropertyS(ctx context.Context, val string) error {
	return class.SetProperty(ctx, "s", val)
}

func (class *ClassHeldBySmartPtr) ReturnThis(ctx context.Context) (embind.ClassBase, error) {
	res, err := class.CallMethod(ctx, "returnThis")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(embind.ClassBase), nil
}

func (class *ClassHeldBySmartPtr) StaticNewCustomPtr(ctx context.Context, arg0 int32, arg1 string) (embind.ClassBase, error) {
	res, err := class.CallInstanceMethod(ctx, nil, "newCustomPtr", arg0, arg1)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(embind.ClassBase), nil
}
func ClassHeldBySmartPtrStaticNewCustomPtr(e embind.Engine, ctx context.Context, arg0 int32, arg1 string) (embind.ClassBase, error) {
	res, err := e.CallStaticClassMethod(ctx, "HeldBySmartPtr", "newCustomPtr", arg0, arg1)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(embind.ClassBase), nil
}

func NewClassHeldBySmartPtr(e embind.Engine, ctx context.Context, arg0 int32, arg1 string) (*ClassHeldBySmartPtr, error) {
	res, err := e.CallPublicSymbol(ctx, "HeldBySmartPtr", arg0, arg1)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(*ClassHeldBySmartPtr), nil
}

type ClassIntTemplateClass struct {
	embind.ClassBase
}

func (class *ClassIntTemplateClass) Clone(ctx context.Context) (*ClassIntTemplateClass, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassIntTemplateClass), nil
}

func (class *ClassIntTemplateClass) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassIntTemplateClass) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassIntTemplateClass) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassIntTemplateClass) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassIntTemplateClass) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassIntTemplateClass) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassIntTemplateClass) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassIntTemplateClass) GetMember(ctx context.Context, arg0 int32) (int32, error) {
	res, err := class.CallMethod(ctx, "getMember", arg0)
	if err != nil {
		return int32(0), err
	}

	if res == nil {
		return int32(0), nil
	}

	return res.(int32), nil
}

func NewClassIntTemplateClass(e embind.Engine, ctx context.Context, arg0 int32, arg1 int32, arg2 int32) (*ClassIntTemplateClass, error) {
	res, err := e.CallPublicSymbol(ctx, "IntTemplateClass", arg0, arg1, arg2)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(*ClassIntTemplateClass), nil
}

type ClassIntegerVector struct {
	embind.ClassBase
}

func (class *ClassIntegerVector) Clone(ctx context.Context) (*ClassIntegerVector, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassIntegerVector), nil
}

func (class *ClassIntegerVector) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassIntegerVector) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassIntegerVector) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassIntegerVector) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassIntegerVector) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassIntegerVector) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassIntegerVector) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassIntegerVector) Get(ctx context.Context, arg0 uint32) (any, error) {
	res, err := class.CallMethod(ctx, "get", arg0)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(any), nil
}

func (class *ClassIntegerVector) Push_back(ctx context.Context, arg0 int32) error {
	_, err := class.CallMethod(ctx, "push_back", arg0)
	return err
}

func (class *ClassIntegerVector) Resize(ctx context.Context, arg0 uint32, arg1 int32) error {
	_, err := class.CallMethod(ctx, "resize", arg0, arg1)
	return err
}

func (class *ClassIntegerVector) Set(ctx context.Context, arg0 uint32, arg1 int32) (bool, error) {
	res, err := class.CallMethod(ctx, "set", arg0, arg1)
	if err != nil {
		return bool(false), err
	}

	if res == nil {
		return bool(false), nil
	}

	return res.(bool), nil
}

func (class *ClassIntegerVector) Size(ctx context.Context) (uint32, error) {
	res, err := class.CallMethod(ctx, "size")
	if err != nil {
		return uint32(0), err
	}

	if res == nil {
		return uint32(0), nil
	}

	return res.(uint32), nil
}

func NewClassIntegerVector(e embind.Engine, ctx context.Context) (*ClassIntegerVector, error) {
	res, err := e.CallPublicSymbol(ctx, "IntegerVector")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(*ClassIntegerVector), nil
}

type ClassIntegerVectorVector struct {
	embind.ClassBase
}

func (class *ClassIntegerVectorVector) Clone(ctx context.Context) (*ClassIntegerVectorVector, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassIntegerVectorVector), nil
}

func (class *ClassIntegerVectorVector) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassIntegerVectorVector) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassIntegerVectorVector) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassIntegerVectorVector) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassIntegerVectorVector) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassIntegerVectorVector) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassIntegerVectorVector) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassIntegerVectorVector) Get(ctx context.Context, arg0 uint32) (any, error) {
	res, err := class.CallMethod(ctx, "get", arg0)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(any), nil
}

func (class *ClassIntegerVectorVector) Push_back(ctx context.Context, arg0 embind.ClassBase) error {
	_, err := class.CallMethod(ctx, "push_back", arg0)
	return err
}

func (class *ClassIntegerVectorVector) Resize(ctx context.Context, arg0 uint32, arg1 embind.ClassBase) error {
	_, err := class.CallMethod(ctx, "resize", arg0, arg1)
	return err
}

func (class *ClassIntegerVectorVector) Set(ctx context.Context, arg0 uint32, arg1 embind.ClassBase) (bool, error) {
	res, err := class.CallMethod(ctx, "set", arg0, arg1)
	if err != nil {
		return bool(false), err
	}

	if res == nil {
		return bool(false), nil
	}

	return res.(bool), nil
}

func (class *ClassIntegerVectorVector) Size(ctx context.Context) (uint32, error) {
	res, err := class.CallMethod(ctx, "size")
	if err != nil {
		return uint32(0), err
	}

	if res == nil {
		return uint32(0), nil
	}

	return res.(uint32), nil
}

func NewClassIntegerVectorVector(e embind.Engine, ctx context.Context) (*ClassIntegerVectorVector, error) {
	res, err := e.CallPublicSymbol(ctx, "IntegerVectorVector")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(*ClassIntegerVectorVector), nil
}

type ClassInterface struct {
	embind.ClassBase
}

func (class *ClassInterface) Clone(ctx context.Context) (*ClassInterface, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassInterface), nil
}

func (class *ClassInterface) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassInterface) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassInterface) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassInterface) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassInterface) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassInterface) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassInterface) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassInterface) Invoke(ctx context.Context, arg0 string) error {
	_, err := class.CallMethod(ctx, "invoke", arg0)
	return err
}

func (class *ClassInterface) StaticExtend(ctx context.Context, arg0 string, arg1 any) (any, error) {
	res, err := class.CallInstanceMethod(ctx, nil, "extend", arg0, arg1)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(any), nil
}
func ClassInterfaceStaticExtend(e embind.Engine, ctx context.Context, arg0 string, arg1 any) (any, error) {
	res, err := e.CallStaticClassMethod(ctx, "Interface", "extend", arg0, arg1)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(any), nil
}

func (class *ClassInterface) StaticImplement(ctx context.Context, arg0 any) (embind.ClassBase, error) {
	res, err := class.CallInstanceMethod(ctx, nil, "implement", arg0)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(embind.ClassBase), nil
}
func ClassInterfaceStaticImplement(e embind.Engine, ctx context.Context, arg0 any) (embind.ClassBase, error) {
	res, err := e.CallStaticClassMethod(ctx, "Interface", "implement", arg0)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(embind.ClassBase), nil
}

type ClassInterfaceWrapper struct {
	embind.ClassBase
}

func (class *ClassInterfaceWrapper) Clone(ctx context.Context) (*ClassInterfaceWrapper, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassInterfaceWrapper), nil
}

func (class *ClassInterfaceWrapper) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassInterfaceWrapper) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassInterfaceWrapper) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassInterfaceWrapper) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassInterfaceWrapper) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassInterfaceWrapper) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassInterfaceWrapper) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassInterfaceWrapper) Invoke(ctx context.Context, arg0 string) error {
	_, err := class.CallMethod(ctx, "invoke", arg0)
	return err
}

func (class *ClassInterfaceWrapper) NotifyOnDestruction(ctx context.Context) error {
	_, err := class.CallMethod(ctx, "notifyOnDestruction")
	return err
}

func (class *ClassInterfaceWrapper) StaticExtend(ctx context.Context, arg0 string, arg1 any) (any, error) {
	res, err := class.CallInstanceMethod(ctx, nil, "extend", arg0, arg1)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(any), nil
}
func ClassInterfaceWrapperStaticExtend(e embind.Engine, ctx context.Context, arg0 string, arg1 any) (any, error) {
	res, err := e.CallStaticClassMethod(ctx, "InterfaceWrapper", "extend", arg0, arg1)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(any), nil
}

func (class *ClassInterfaceWrapper) StaticImplement(ctx context.Context, arg0 any) (embind.ClassBase, error) {
	res, err := class.CallInstanceMethod(ctx, nil, "implement", arg0)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(embind.ClassBase), nil
}
func ClassInterfaceWrapperStaticImplement(e embind.Engine, ctx context.Context, arg0 any) (embind.ClassBase, error) {
	res, err := e.CallStaticClassMethod(ctx, "InterfaceWrapper", "implement", arg0)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(embind.ClassBase), nil
}

type ClassIntrusiveClass struct {
	embind.ClassBase
}

func (class *ClassIntrusiveClass) Clone(ctx context.Context) (*ClassIntrusiveClass, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassIntrusiveClass), nil
}

func (class *ClassIntrusiveClass) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassIntrusiveClass) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassIntrusiveClass) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassIntrusiveClass) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassIntrusiveClass) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassIntrusiveClass) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassIntrusiveClass) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassIntrusiveClass) StaticExtend(ctx context.Context, arg0 string, arg1 any) (any, error) {
	res, err := class.CallInstanceMethod(ctx, nil, "extend", arg0, arg1)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(any), nil
}
func ClassIntrusiveClassStaticExtend(e embind.Engine, ctx context.Context, arg0 string, arg1 any) (any, error) {
	res, err := e.CallStaticClassMethod(ctx, "IntrusiveClass", "extend", arg0, arg1)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(any), nil
}

func (class *ClassIntrusiveClass) StaticImplement(ctx context.Context, arg0 any) (embind.ClassBase, error) {
	res, err := class.CallInstanceMethod(ctx, nil, "implement", arg0)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(embind.ClassBase), nil
}
func ClassIntrusiveClassStaticImplement(e embind.Engine, ctx context.Context, arg0 any) (embind.ClassBase, error) {
	res, err := e.CallStaticClassMethod(ctx, "IntrusiveClass", "implement", arg0)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(embind.ClassBase), nil
}

func NewClassIntrusiveClass(e embind.Engine, ctx context.Context) (*ClassIntrusiveClass, error) {
	res, err := e.CallPublicSymbol(ctx, "IntrusiveClass")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(*ClassIntrusiveClass), nil
}

type ClassIntrusiveClassHolder struct {
	embind.ClassBase
}

func (class *ClassIntrusiveClassHolder) Clone(ctx context.Context) (*ClassIntrusiveClassHolder, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassIntrusiveClassHolder), nil
}

func (class *ClassIntrusiveClassHolder) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassIntrusiveClassHolder) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassIntrusiveClassHolder) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassIntrusiveClassHolder) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassIntrusiveClassHolder) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassIntrusiveClassHolder) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassIntrusiveClassHolder) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassIntrusiveClassHolder) Get(ctx context.Context) (embind.ClassBase, error) {
	res, err := class.CallMethod(ctx, "get")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(embind.ClassBase), nil
}

func (class *ClassIntrusiveClassHolder) Set(ctx context.Context, arg0 embind.ClassBase) error {
	_, err := class.CallMethod(ctx, "set", arg0)
	return err
}

func NewClassIntrusiveClassHolder(e embind.Engine, ctx context.Context) (*ClassIntrusiveClassHolder, error) {
	res, err := e.CallPublicSymbol(ctx, "IntrusiveClassHolder")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(*ClassIntrusiveClassHolder), nil
}

type ClassIntrusiveClassWrapper struct {
	embind.ClassBase
}

func (class *ClassIntrusiveClassWrapper) Clone(ctx context.Context) (*ClassIntrusiveClassWrapper, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassIntrusiveClassWrapper), nil
}

func (class *ClassIntrusiveClassWrapper) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassIntrusiveClassWrapper) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassIntrusiveClassWrapper) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassIntrusiveClassWrapper) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassIntrusiveClassWrapper) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassIntrusiveClassWrapper) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassIntrusiveClassWrapper) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassIntrusiveClassWrapper) NotifyOnDestruction(ctx context.Context) error {
	_, err := class.CallMethod(ctx, "notifyOnDestruction")
	return err
}

func (class *ClassIntrusiveClassWrapper) StaticExtend(ctx context.Context, arg0 string, arg1 any) (any, error) {
	res, err := class.CallInstanceMethod(ctx, nil, "extend", arg0, arg1)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(any), nil
}
func ClassIntrusiveClassWrapperStaticExtend(e embind.Engine, ctx context.Context, arg0 string, arg1 any) (any, error) {
	res, err := e.CallStaticClassMethod(ctx, "IntrusiveClassWrapper", "extend", arg0, arg1)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(any), nil
}

func (class *ClassIntrusiveClassWrapper) StaticImplement(ctx context.Context, arg0 any) (embind.ClassBase, error) {
	res, err := class.CallInstanceMethod(ctx, nil, "implement", arg0)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(embind.ClassBase), nil
}
func ClassIntrusiveClassWrapperStaticImplement(e embind.Engine, ctx context.Context, arg0 any) (embind.ClassBase, error) {
	res, err := e.CallStaticClassMethod(ctx, "IntrusiveClassWrapper", "implement", arg0)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(embind.ClassBase), nil
}

type ClassMap_int__string_ struct {
	embind.ClassBase
}

func (class *ClassMap_int__string_) Clone(ctx context.Context) (*ClassMap_int__string_, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassMap_int__string_), nil
}

func (class *ClassMap_int__string_) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassMap_int__string_) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassMap_int__string_) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassMap_int__string_) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassMap_int__string_) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassMap_int__string_) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassMap_int__string_) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassMap_int__string_) Get(ctx context.Context, arg0 int32) (any, error) {
	res, err := class.CallMethod(ctx, "get", arg0)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(any), nil
}

func (class *ClassMap_int__string_) Keys(ctx context.Context) (embind.ClassBase, error) {
	res, err := class.CallMethod(ctx, "keys")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(embind.ClassBase), nil
}

func (class *ClassMap_int__string_) Set(ctx context.Context, arg0 int32, arg1 string) error {
	_, err := class.CallMethod(ctx, "set", arg0, arg1)
	return err
}

func (class *ClassMap_int__string_) Size(ctx context.Context) (uint32, error) {
	res, err := class.CallMethod(ctx, "size")
	if err != nil {
		return uint32(0), err
	}

	if res == nil {
		return uint32(0), nil
	}

	return res.(uint32), nil
}

func NewClassMap_int__string_(e embind.Engine, ctx context.Context) (*ClassMap_int__string_, error) {
	res, err := e.CallPublicSymbol(ctx, "map_int__string_")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(*ClassMap_int__string_), nil
}

type ClassMultipleAccessors struct {
	embind.ClassBase
}

func (class *ClassMultipleAccessors) Clone(ctx context.Context) (*ClassMultipleAccessors, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassMultipleAccessors), nil
}

func (class *ClassMultipleAccessors) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassMultipleAccessors) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassMultipleAccessors) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassMultipleAccessors) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassMultipleAccessors) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassMultipleAccessors) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassMultipleAccessors) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassMultipleAccessors) GetConst(ctx context.Context, arg0 int32) (int32, error) {
	res, err := class.CallMethod(ctx, "getConst", arg0)
	if err != nil {
		return int32(0), err
	}

	if res == nil {
		return int32(0), nil
	}

	return res.(int32), nil
}

type ClassMultipleCtors struct {
	embind.ClassBase
}

func (class *ClassMultipleCtors) Clone(ctx context.Context) (*ClassMultipleCtors, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassMultipleCtors), nil
}

func (class *ClassMultipleCtors) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassMultipleCtors) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassMultipleCtors) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassMultipleCtors) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassMultipleCtors) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassMultipleCtors) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassMultipleCtors) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassMultipleCtors) WhichCtorCalled(ctx context.Context) (int32, error) {
	res, err := class.CallMethod(ctx, "WhichCtorCalled")
	if err != nil {
		return int32(0), err
	}

	if res == nil {
		return int32(0), nil
	}

	return res.(int32), nil
}

func NewClassMultipleCtors1(e embind.Engine, ctx context.Context, arg0 int32) (*ClassMultipleCtors, error) {
	res, err := e.CallPublicSymbol(ctx, "MultipleCtors", arg0)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(*ClassMultipleCtors), nil
}

func NewClassMultipleCtors2(e embind.Engine, ctx context.Context, arg0 int32, arg1 int32) (*ClassMultipleCtors, error) {
	res, err := e.CallPublicSymbol(ctx, "MultipleCtors", arg0, arg1)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(*ClassMultipleCtors), nil
}

func NewClassMultipleCtors3(e embind.Engine, ctx context.Context, arg0 int32, arg1 int32, arg2 int32) (*ClassMultipleCtors, error) {
	res, err := e.CallPublicSymbol(ctx, "MultipleCtors", arg0, arg1, arg2)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(*ClassMultipleCtors), nil
}

type ClassMultipleOverloads struct {
	embind.ClassBase
}

func (class *ClassMultipleOverloads) Clone(ctx context.Context) (*ClassMultipleOverloads, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassMultipleOverloads), nil
}

func (class *ClassMultipleOverloads) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassMultipleOverloads) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassMultipleOverloads) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassMultipleOverloads) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassMultipleOverloads) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassMultipleOverloads) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassMultipleOverloads) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassMultipleOverloads) Func1(ctx context.Context, arg0 int32) (int32, error) {
	res, err := class.CallMethod(ctx, "Func", arg0)
	if err != nil {
		return int32(0), err
	}

	if res == nil {
		return int32(0), nil
	}

	return res.(int32), nil
}

func (class *ClassMultipleOverloads) Func2(ctx context.Context, arg0 int32, arg1 int32) (int32, error) {
	res, err := class.CallMethod(ctx, "Func", arg0, arg1)
	if err != nil {
		return int32(0), err
	}

	if res == nil {
		return int32(0), nil
	}

	return res.(int32), nil
}

func (class *ClassMultipleOverloads) WhichFuncCalled(ctx context.Context) (int32, error) {
	res, err := class.CallMethod(ctx, "WhichFuncCalled")
	if err != nil {
		return int32(0), err
	}

	if res == nil {
		return int32(0), nil
	}

	return res.(int32), nil
}

func (class *ClassMultipleOverloads) StaticStaticFunc1(ctx context.Context, arg0 int32) (int32, error) {
	res, err := class.CallInstanceMethod(ctx, nil, "StaticFunc", arg0)
	if err != nil {
		return int32(0), err
	}

	if res == nil {
		return int32(0), nil
	}

	return res.(int32), nil
}
func ClassMultipleOverloadsStaticStaticFunc1(e embind.Engine, ctx context.Context, arg0 int32) (int32, error) {
	res, err := e.CallStaticClassMethod(ctx, "MultipleOverloads", "StaticFunc", arg0)
	if err != nil {
		return int32(0), err
	}

	if res == nil {
		return int32(0), nil
	}

	return res.(int32), nil
}

func (class *ClassMultipleOverloads) StaticStaticFunc2(ctx context.Context, arg0 int32, arg1 int32) (int32, error) {
	res, err := class.CallInstanceMethod(ctx, nil, "StaticFunc", arg0, arg1)
	if err != nil {
		return int32(0), err
	}

	if res == nil {
		return int32(0), nil
	}

	return res.(int32), nil
}
func ClassMultipleOverloadsStaticStaticFunc2(e embind.Engine, ctx context.Context, arg0 int32, arg1 int32) (int32, error) {
	res, err := e.CallStaticClassMethod(ctx, "MultipleOverloads", "StaticFunc", arg0, arg1)
	if err != nil {
		return int32(0), err
	}

	if res == nil {
		return int32(0), nil
	}

	return res.(int32), nil
}

func (class *ClassMultipleOverloads) StaticWhichStaticFuncCalled(ctx context.Context) (int32, error) {
	res, err := class.CallInstanceMethod(ctx, nil, "WhichStaticFuncCalled")
	if err != nil {
		return int32(0), err
	}

	if res == nil {
		return int32(0), nil
	}

	return res.(int32), nil
}
func ClassMultipleOverloadsStaticWhichStaticFuncCalled(e embind.Engine, ctx context.Context) (int32, error) {
	res, err := e.CallStaticClassMethod(ctx, "MultipleOverloads", "WhichStaticFuncCalled")
	if err != nil {
		return int32(0), err
	}

	if res == nil {
		return int32(0), nil
	}

	return res.(int32), nil
}

func NewClassMultipleOverloads(e embind.Engine, ctx context.Context) (*ClassMultipleOverloads, error) {
	res, err := e.CallPublicSymbol(ctx, "MultipleOverloads")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(*ClassMultipleOverloads), nil
}

type ClassMultipleOverloadsDependingOnDummy struct {
	embind.ClassBase
}

func (class *ClassMultipleOverloadsDependingOnDummy) Clone(ctx context.Context) (*ClassMultipleOverloadsDependingOnDummy, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassMultipleOverloadsDependingOnDummy), nil
}

func (class *ClassMultipleOverloadsDependingOnDummy) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassMultipleOverloadsDependingOnDummy) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassMultipleOverloadsDependingOnDummy) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassMultipleOverloadsDependingOnDummy) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassMultipleOverloadsDependingOnDummy) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassMultipleOverloadsDependingOnDummy) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassMultipleOverloadsDependingOnDummy) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassMultipleOverloadsDependingOnDummy) Dummy0(ctx context.Context) (embind.ClassBase, error) {
	res, err := class.CallMethod(ctx, "dummy")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(embind.ClassBase), nil
}

func (class *ClassMultipleOverloadsDependingOnDummy) Dummy1(ctx context.Context, arg0 embind.ClassBase) (embind.ClassBase, error) {
	res, err := class.CallMethod(ctx, "dummy", arg0)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(embind.ClassBase), nil
}

func (class *ClassMultipleOverloadsDependingOnDummy) StaticStaticDummy0(ctx context.Context) (embind.ClassBase, error) {
	res, err := class.CallInstanceMethod(ctx, nil, "staticDummy")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(embind.ClassBase), nil
}
func ClassMultipleOverloadsDependingOnDummyStaticStaticDummy0(e embind.Engine, ctx context.Context) (embind.ClassBase, error) {
	res, err := e.CallStaticClassMethod(ctx, "MultipleOverloadsDependingOnDummy", "staticDummy")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(embind.ClassBase), nil
}

func (class *ClassMultipleOverloadsDependingOnDummy) StaticStaticDummy1(ctx context.Context, arg0 embind.ClassBase) (embind.ClassBase, error) {
	res, err := class.CallInstanceMethod(ctx, nil, "staticDummy", arg0)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(embind.ClassBase), nil
}
func ClassMultipleOverloadsDependingOnDummyStaticStaticDummy1(e embind.Engine, ctx context.Context, arg0 embind.ClassBase) (embind.ClassBase, error) {
	res, err := e.CallStaticClassMethod(ctx, "MultipleOverloadsDependingOnDummy", "staticDummy", arg0)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(embind.ClassBase), nil
}

func NewClassMultipleOverloadsDependingOnDummy(e embind.Engine, ctx context.Context) (*ClassMultipleOverloadsDependingOnDummy, error) {
	res, err := e.CallPublicSymbol(ctx, "MultipleOverloadsDependingOnDummy")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(*ClassMultipleOverloadsDependingOnDummy), nil
}

type ClassMultipleOverloadsDerived struct {
	embind.ClassBase
}

func (class *ClassMultipleOverloadsDerived) Clone(ctx context.Context) (*ClassMultipleOverloadsDerived, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassMultipleOverloadsDerived), nil
}

func (class *ClassMultipleOverloadsDerived) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassMultipleOverloadsDerived) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassMultipleOverloadsDerived) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassMultipleOverloadsDerived) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassMultipleOverloadsDerived) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassMultipleOverloadsDerived) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassMultipleOverloadsDerived) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassMultipleOverloadsDerived) Func1(ctx context.Context, arg0 int32) (int32, error) {
	res, err := class.CallMethod(ctx, "Func", arg0)
	if err != nil {
		return int32(0), err
	}

	if res == nil {
		return int32(0), nil
	}

	return res.(int32), nil
}

func (class *ClassMultipleOverloadsDerived) Func2(ctx context.Context, arg0 int32, arg1 int32) (int32, error) {
	res, err := class.CallMethod(ctx, "Func", arg0, arg1)
	if err != nil {
		return int32(0), err
	}

	if res == nil {
		return int32(0), nil
	}

	return res.(int32), nil
}

func (class *ClassMultipleOverloadsDerived) Func3(ctx context.Context, arg0 int32, arg1 int32, arg2 int32) (int32, error) {
	res, err := class.CallMethod(ctx, "Func", arg0, arg1, arg2)
	if err != nil {
		return int32(0), err
	}

	if res == nil {
		return int32(0), nil
	}

	return res.(int32), nil
}

func (class *ClassMultipleOverloadsDerived) Func4(ctx context.Context, arg0 int32, arg1 int32, arg2 int32, arg3 int32) (int32, error) {
	res, err := class.CallMethod(ctx, "Func", arg0, arg1, arg2, arg3)
	if err != nil {
		return int32(0), err
	}

	if res == nil {
		return int32(0), nil
	}

	return res.(int32), nil
}

func (class *ClassMultipleOverloadsDerived) WhichFuncCalled(ctx context.Context) (int32, error) {
	res, err := class.CallMethod(ctx, "WhichFuncCalled")
	if err != nil {
		return int32(0), err
	}

	if res == nil {
		return int32(0), nil
	}

	return res.(int32), nil
}

func (class *ClassMultipleOverloadsDerived) StaticStaticFunc1(ctx context.Context, arg0 int32) (int32, error) {
	res, err := class.CallInstanceMethod(ctx, nil, "StaticFunc", arg0)
	if err != nil {
		return int32(0), err
	}

	if res == nil {
		return int32(0), nil
	}

	return res.(int32), nil
}
func ClassMultipleOverloadsDerivedStaticStaticFunc1(e embind.Engine, ctx context.Context, arg0 int32) (int32, error) {
	res, err := e.CallStaticClassMethod(ctx, "MultipleOverloadsDerived", "StaticFunc", arg0)
	if err != nil {
		return int32(0), err
	}

	if res == nil {
		return int32(0), nil
	}

	return res.(int32), nil
}

func (class *ClassMultipleOverloadsDerived) StaticStaticFunc2(ctx context.Context, arg0 int32, arg1 int32) (int32, error) {
	res, err := class.CallInstanceMethod(ctx, nil, "StaticFunc", arg0, arg1)
	if err != nil {
		return int32(0), err
	}

	if res == nil {
		return int32(0), nil
	}

	return res.(int32), nil
}
func ClassMultipleOverloadsDerivedStaticStaticFunc2(e embind.Engine, ctx context.Context, arg0 int32, arg1 int32) (int32, error) {
	res, err := e.CallStaticClassMethod(ctx, "MultipleOverloadsDerived", "StaticFunc", arg0, arg1)
	if err != nil {
		return int32(0), err
	}

	if res == nil {
		return int32(0), nil
	}

	return res.(int32), nil
}

func (class *ClassMultipleOverloadsDerived) StaticStaticFunc3(ctx context.Context, arg0 int32, arg1 int32, arg2 int32) (int32, error) {
	res, err := class.CallInstanceMethod(ctx, nil, "StaticFunc", arg0, arg1, arg2)
	if err != nil {
		return int32(0), err
	}

	if res == nil {
		return int32(0), nil
	}

	return res.(int32), nil
}
func ClassMultipleOverloadsDerivedStaticStaticFunc3(e embind.Engine, ctx context.Context, arg0 int32, arg1 int32, arg2 int32) (int32, error) {
	res, err := e.CallStaticClassMethod(ctx, "MultipleOverloadsDerived", "StaticFunc", arg0, arg1, arg2)
	if err != nil {
		return int32(0), err
	}

	if res == nil {
		return int32(0), nil
	}

	return res.(int32), nil
}

func (class *ClassMultipleOverloadsDerived) StaticStaticFunc4(ctx context.Context, arg0 int32, arg1 int32, arg2 int32, arg3 int32) (int32, error) {
	res, err := class.CallInstanceMethod(ctx, nil, "StaticFunc", arg0, arg1, arg2, arg3)
	if err != nil {
		return int32(0), err
	}

	if res == nil {
		return int32(0), nil
	}

	return res.(int32), nil
}
func ClassMultipleOverloadsDerivedStaticStaticFunc4(e embind.Engine, ctx context.Context, arg0 int32, arg1 int32, arg2 int32, arg3 int32) (int32, error) {
	res, err := e.CallStaticClassMethod(ctx, "MultipleOverloadsDerived", "StaticFunc", arg0, arg1, arg2, arg3)
	if err != nil {
		return int32(0), err
	}

	if res == nil {
		return int32(0), nil
	}

	return res.(int32), nil
}

func (class *ClassMultipleOverloadsDerived) StaticWhichStaticFuncCalled(ctx context.Context) (int32, error) {
	res, err := class.CallInstanceMethod(ctx, nil, "WhichStaticFuncCalled")
	if err != nil {
		return int32(0), err
	}

	if res == nil {
		return int32(0), nil
	}

	return res.(int32), nil
}
func ClassMultipleOverloadsDerivedStaticWhichStaticFuncCalled(e embind.Engine, ctx context.Context) (int32, error) {
	res, err := e.CallStaticClassMethod(ctx, "MultipleOverloadsDerived", "WhichStaticFuncCalled")
	if err != nil {
		return int32(0), err
	}

	if res == nil {
		return int32(0), nil
	}

	return res.(int32), nil
}

func NewClassMultipleOverloadsDerived(e embind.Engine, ctx context.Context) (*ClassMultipleOverloadsDerived, error) {
	res, err := e.CallPublicSymbol(ctx, "MultipleOverloadsDerived")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(*ClassMultipleOverloadsDerived), nil
}

type ClassMultipleSmartCtors struct {
	embind.ClassBase
}

func (class *ClassMultipleSmartCtors) Clone(ctx context.Context) (*ClassMultipleSmartCtors, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassMultipleSmartCtors), nil
}

func (class *ClassMultipleSmartCtors) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassMultipleSmartCtors) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassMultipleSmartCtors) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassMultipleSmartCtors) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassMultipleSmartCtors) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassMultipleSmartCtors) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassMultipleSmartCtors) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassMultipleSmartCtors) WhichCtorCalled(ctx context.Context) (int32, error) {
	res, err := class.CallMethod(ctx, "WhichCtorCalled")
	if err != nil {
		return int32(0), err
	}

	if res == nil {
		return int32(0), nil
	}

	return res.(int32), nil
}

func NewClassMultipleSmartCtors1(e embind.Engine, ctx context.Context, arg0 int32) (*ClassMultipleSmartCtors, error) {
	res, err := e.CallPublicSymbol(ctx, "MultipleSmartCtors", arg0)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(*ClassMultipleSmartCtors), nil
}

func NewClassMultipleSmartCtors2(e embind.Engine, ctx context.Context, arg0 int32, arg1 int32) (*ClassMultipleSmartCtors, error) {
	res, err := e.CallPublicSymbol(ctx, "MultipleSmartCtors", arg0, arg1)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(*ClassMultipleSmartCtors), nil
}

type ClassMultiplyDerived struct {
	embind.ClassBase
}

func (class *ClassMultiplyDerived) Clone(ctx context.Context) (*ClassMultiplyDerived, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassMultiplyDerived), nil
}

func (class *ClassMultiplyDerived) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassMultiplyDerived) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassMultiplyDerived) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassMultiplyDerived) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassMultiplyDerived) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassMultiplyDerived) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassMultiplyDerived) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassMultiplyDerived) GetPropertyBaseMember(ctx context.Context) (int32, error) {
	res, err := class.GetProperty(ctx, "baseMember")
	if err != nil {
		return int32(0), err
	}

	if res == nil {
		return int32(0), nil
	}

	return res.(int32), nil
}
func (class *ClassMultiplyDerived) SetPropertyBaseMember(ctx context.Context, val int32) error {
	return class.SetProperty(ctx, "baseMember", val)
}

func (class *ClassMultiplyDerived) GetPropertyMember(ctx context.Context) (int32, error) {
	res, err := class.GetProperty(ctx, "member")
	if err != nil {
		return int32(0), err
	}

	if res == nil {
		return int32(0), nil
	}

	return res.(int32), nil
}
func (class *ClassMultiplyDerived) SetPropertyMember(ctx context.Context, val int32) error {
	return class.SetProperty(ctx, "member", val)
}

func (class *ClassMultiplyDerived) GetBaseMember(ctx context.Context) (int32, error) {
	res, err := class.CallMethod(ctx, "getBaseMember")
	if err != nil {
		return int32(0), err
	}

	if res == nil {
		return int32(0), nil
	}

	return res.(int32), nil
}

func (class *ClassMultiplyDerived) GetClassName(ctx context.Context) (string, error) {
	res, err := class.CallMethod(ctx, "getClassName")
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}

func (class *ClassMultiplyDerived) GetClassNameFromBase(ctx context.Context) (string, error) {
	res, err := class.CallMethod(ctx, "getClassNameFromBase")
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}

func (class *ClassMultiplyDerived) GetClassNameNotAvailableInDerivedClasses(ctx context.Context) (string, error) {
	res, err := class.CallMethod(ctx, "getClassNameNotAvailableInDerivedClasses")
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}

func (class *ClassMultiplyDerived) GetMember(ctx context.Context) (int32, error) {
	res, err := class.CallMethod(ctx, "getMember")
	if err != nil {
		return int32(0), err
	}

	if res == nil {
		return int32(0), nil
	}

	return res.(int32), nil
}

func (class *ClassMultiplyDerived) SetBaseMember(ctx context.Context, arg0 int32) error {
	_, err := class.CallMethod(ctx, "setBaseMember", arg0)
	return err
}

func (class *ClassMultiplyDerived) SetMember(ctx context.Context, arg0 int32) error {
	_, err := class.CallMethod(ctx, "setMember", arg0)
	return err
}

func (class *ClassMultiplyDerived) StaticClassFunction(ctx context.Context) (string, error) {
	res, err := class.CallInstanceMethod(ctx, nil, "classFunction")
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}
func ClassMultiplyDerivedStaticClassFunction(e embind.Engine, ctx context.Context) (string, error) {
	res, err := e.CallStaticClassMethod(ctx, "MultiplyDerived", "classFunction")
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}

func (class *ClassMultiplyDerived) StaticGetInstanceCount(ctx context.Context) (int32, error) {
	res, err := class.CallInstanceMethod(ctx, nil, "getInstanceCount")
	if err != nil {
		return int32(0), err
	}

	if res == nil {
		return int32(0), nil
	}

	return res.(int32), nil
}
func ClassMultiplyDerivedStaticGetInstanceCount(e embind.Engine, ctx context.Context) (int32, error) {
	res, err := e.CallStaticClassMethod(ctx, "MultiplyDerived", "getInstanceCount")
	if err != nil {
		return int32(0), err
	}

	if res == nil {
		return int32(0), nil
	}

	return res.(int32), nil
}

func NewClassMultiplyDerived(e embind.Engine, ctx context.Context) (*ClassMultiplyDerived, error) {
	res, err := e.CallPublicSymbol(ctx, "MultiplyDerived")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(*ClassMultiplyDerived), nil
}

type ClassMyClass struct {
	embind.ClassBase
}

func (class *ClassMyClass) Clone(ctx context.Context) (*ClassMyClass, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassMyClass), nil
}

func (class *ClassMyClass) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassMyClass) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassMyClass) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassMyClass) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassMyClass) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassMyClass) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassMyClass) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassMyClass) GetPropertyX(ctx context.Context) (int32, error) {
	res, err := class.GetProperty(ctx, "x")
	if err != nil {
		return int32(0), err
	}

	if res == nil {
		return int32(0), nil
	}

	return res.(int32), nil
}
func (class *ClassMyClass) SetPropertyX(ctx context.Context, val int32) error {
	return class.SetProperty(ctx, "x", val)
}

func (class *ClassMyClass) GetPropertyY(ctx context.Context) (string, error) {
	res, err := class.GetProperty(ctx, "y")
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}

func (class *ClassMyClass) CombineY(ctx context.Context, arg0 string) (string, error) {
	res, err := class.CallMethod(ctx, "combineY", arg0)
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}

func (class *ClassMyClass) IncrementX0(ctx context.Context) error {
	_, err := class.CallMethod(ctx, "incrementX")
	return err
}

func (class *ClassMyClass) IncrementX1(ctx context.Context, arg0 int32) error {
	_, err := class.CallMethod(ctx, "incrementX", arg0)
	return err
}

func (class *ClassMyClass) StaticGetStringFromInstance(ctx context.Context, arg0 embind.ClassBase) (string, error) {
	res, err := class.CallInstanceMethod(ctx, nil, "getStringFromInstance", arg0)
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}
func ClassMyClassStaticGetStringFromInstance(e embind.Engine, ctx context.Context, arg0 embind.ClassBase) (string, error) {
	res, err := e.CallStaticClassMethod(ctx, "MyClass", "getStringFromInstance", arg0)
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}

func NewClassMyClass1(e embind.Engine, ctx context.Context, arg0 int32) (*ClassMyClass, error) {
	res, err := e.CallPublicSymbol(ctx, "MyClass", arg0)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(*ClassMyClass), nil
}

func NewClassMyClass2(e embind.Engine, ctx context.Context, arg0 int32, arg1 string) (*ClassMyClass, error) {
	res, err := e.CallPublicSymbol(ctx, "MyClass", arg0, arg1)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(*ClassMyClass), nil
}

type ClassNoExceptClass struct {
	embind.ClassBase
}

func (class *ClassNoExceptClass) Clone(ctx context.Context) (*ClassNoExceptClass, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassNoExceptClass), nil
}

func (class *ClassNoExceptClass) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassNoExceptClass) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassNoExceptClass) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassNoExceptClass) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassNoExceptClass) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassNoExceptClass) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassNoExceptClass) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassNoExceptClass) GetPropertyX(ctx context.Context) (int32, error) {
	res, err := class.GetProperty(ctx, "x")
	if err != nil {
		return int32(0), err
	}

	if res == nil {
		return int32(0), nil
	}

	return res.(int32), nil
}
func (class *ClassNoExceptClass) SetPropertyX(ctx context.Context, val int32) error {
	return class.SetProperty(ctx, "x", val)
}

func (class *ClassNoExceptClass) Embind_test_no_except_function(ctx context.Context) error {
	_, err := class.CallMethod(ctx, "embind_test_no_except_function")
	return err
}

func (class *ClassNoExceptClass) GetValue(ctx context.Context) (int32, error) {
	res, err := class.CallMethod(ctx, "getValue")
	if err != nil {
		return int32(0), err
	}

	if res == nil {
		return int32(0), nil
	}

	return res.(int32), nil
}

func (class *ClassNoExceptClass) GetValueConst(ctx context.Context) (int32, error) {
	res, err := class.CallMethod(ctx, "getValueConst")
	if err != nil {
		return int32(0), err
	}

	if res == nil {
		return int32(0), nil
	}

	return res.(int32), nil
}

type ClassNoncopyable struct {
	embind.ClassBase
}

func (class *ClassNoncopyable) Clone(ctx context.Context) (*ClassNoncopyable, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassNoncopyable), nil
}

func (class *ClassNoncopyable) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassNoncopyable) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassNoncopyable) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassNoncopyable) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassNoncopyable) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassNoncopyable) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassNoncopyable) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassNoncopyable) Method(ctx context.Context) (string, error) {
	res, err := class.CallMethod(ctx, "method")
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}

func NewClassNoncopyable(e embind.Engine, ctx context.Context) (*ClassNoncopyable, error) {
	res, err := e.CallPublicSymbol(ctx, "Noncopyable")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(*ClassNoncopyable), nil
}

type ClassParentClass struct {
	embind.ClassBase
}

func (class *ClassParentClass) Clone(ctx context.Context) (*ClassParentClass, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassParentClass), nil
}

func (class *ClassParentClass) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassParentClass) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassParentClass) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassParentClass) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassParentClass) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassParentClass) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassParentClass) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassParentClass) GetBigClass(ctx context.Context) (embind.ClassBase, error) {
	res, err := class.CallMethod(ctx, "getBigClass")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(embind.ClassBase), nil
}

func NewClassParentClass(e embind.Engine, ctx context.Context) (*ClassParentClass, error) {
	res, err := e.CallPublicSymbol(ctx, "ParentClass")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(*ClassParentClass), nil
}

type ClassPolyBase struct {
	embind.ClassBase
}

func (class *ClassPolyBase) Clone(ctx context.Context) (*ClassPolyBase, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassPolyBase), nil
}

func (class *ClassPolyBase) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassPolyBase) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassPolyBase) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassPolyBase) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassPolyBase) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassPolyBase) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassPolyBase) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassPolyBase) GetClassName(ctx context.Context) (string, error) {
	res, err := class.CallMethod(ctx, "getClassName")
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}

func (class *ClassPolyBase) VirtualGetClassName(ctx context.Context) (string, error) {
	res, err := class.CallMethod(ctx, "virtualGetClassName")
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}

func NewClassPolyBase(e embind.Engine, ctx context.Context) (*ClassPolyBase, error) {
	res, err := e.CallPublicSymbol(ctx, "PolyBase")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(*ClassPolyBase), nil
}

type ClassPolyDerived struct {
	embind.ClassBase
}

func (class *ClassPolyDerived) Clone(ctx context.Context) (*ClassPolyDerived, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassPolyDerived), nil
}

func (class *ClassPolyDerived) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassPolyDerived) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassPolyDerived) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassPolyDerived) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassPolyDerived) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassPolyDerived) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassPolyDerived) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassPolyDerived) GetClassName(ctx context.Context) (string, error) {
	res, err := class.CallMethod(ctx, "getClassName")
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}

func (class *ClassPolyDerived) VirtualGetClassName(ctx context.Context) (string, error) {
	res, err := class.CallMethod(ctx, "virtualGetClassName")
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}

func (class *ClassPolyDerived) StaticGetPtr(ctx context.Context) (embind.ClassBase, error) {
	res, err := class.CallInstanceMethod(ctx, nil, "getPtr")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(embind.ClassBase), nil
}
func ClassPolyDerivedStaticGetPtr(e embind.Engine, ctx context.Context) (embind.ClassBase, error) {
	res, err := e.CallStaticClassMethod(ctx, "PolyDerived", "getPtr")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(embind.ClassBase), nil
}

func (class *ClassPolyDerived) StaticGetPtrClassName(ctx context.Context) (string, error) {
	res, err := class.CallInstanceMethod(ctx, nil, "getPtrClassName")
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}
func ClassPolyDerivedStaticGetPtrClassName(e embind.Engine, ctx context.Context) (string, error) {
	res, err := e.CallStaticClassMethod(ctx, "PolyDerived", "getPtrClassName")
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}

func (class *ClassPolyDerived) StaticReleasePtr(ctx context.Context) error {
	_, err := class.CallInstanceMethod(ctx, nil, "releasePtr")
	return err
}
func ClassPolyDerivedStaticReleasePtr(e embind.Engine, ctx context.Context) error {
	_, err := e.CallStaticClassMethod(ctx, "PolyDerived", "releasePtr")
	return err
}

func (class *ClassPolyDerived) StaticSetPtrDerived(ctx context.Context) error {
	_, err := class.CallInstanceMethod(ctx, nil, "setPtrDerived")
	return err
}
func ClassPolyDerivedStaticSetPtrDerived(e embind.Engine, ctx context.Context) error {
	_, err := e.CallStaticClassMethod(ctx, "PolyDerived", "setPtrDerived")
	return err
}

func NewClassPolyDerived(e embind.Engine, ctx context.Context) (*ClassPolyDerived, error) {
	res, err := e.CallPublicSymbol(ctx, "PolyDerived")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(*ClassPolyDerived), nil
}

type ClassPolyDerivedThrice struct {
	embind.ClassBase
}

func (class *ClassPolyDerivedThrice) Clone(ctx context.Context) (*ClassPolyDerivedThrice, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassPolyDerivedThrice), nil
}

func (class *ClassPolyDerivedThrice) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassPolyDerivedThrice) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassPolyDerivedThrice) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassPolyDerivedThrice) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassPolyDerivedThrice) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassPolyDerivedThrice) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassPolyDerivedThrice) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassPolyDerivedThrice) GetClassName(ctx context.Context) (string, error) {
	res, err := class.CallMethod(ctx, "getClassName")
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}

func (class *ClassPolyDerivedThrice) VirtualGetClassName(ctx context.Context) (string, error) {
	res, err := class.CallMethod(ctx, "virtualGetClassName")
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}

func (class *ClassPolyDerivedThrice) StaticGetPtrClassName(ctx context.Context) (string, error) {
	res, err := class.CallInstanceMethod(ctx, nil, "getPtrClassName")
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}
func ClassPolyDerivedThriceStaticGetPtrClassName(e embind.Engine, ctx context.Context) (string, error) {
	res, err := e.CallStaticClassMethod(ctx, "PolyDerivedThrice", "getPtrClassName")
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}

func (class *ClassPolyDerivedThrice) StaticReleasePtr(ctx context.Context) error {
	_, err := class.CallInstanceMethod(ctx, nil, "releasePtr")
	return err
}
func ClassPolyDerivedThriceStaticReleasePtr(e embind.Engine, ctx context.Context) error {
	_, err := e.CallStaticClassMethod(ctx, "PolyDerivedThrice", "releasePtr")
	return err
}

func (class *ClassPolyDerivedThrice) StaticSetPtrDerived(ctx context.Context) error {
	_, err := class.CallInstanceMethod(ctx, nil, "setPtrDerived")
	return err
}
func ClassPolyDerivedThriceStaticSetPtrDerived(e embind.Engine, ctx context.Context) error {
	_, err := e.CallStaticClassMethod(ctx, "PolyDerivedThrice", "setPtrDerived")
	return err
}

func NewClassPolyDerivedThrice(e embind.Engine, ctx context.Context) (*ClassPolyDerivedThrice, error) {
	res, err := e.CallPublicSymbol(ctx, "PolyDerivedThrice")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(*ClassPolyDerivedThrice), nil
}

type ClassPolyDiamondBase struct {
	embind.ClassBase
}

func (class *ClassPolyDiamondBase) Clone(ctx context.Context) (*ClassPolyDiamondBase, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassPolyDiamondBase), nil
}

func (class *ClassPolyDiamondBase) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassPolyDiamondBase) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassPolyDiamondBase) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassPolyDiamondBase) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassPolyDiamondBase) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassPolyDiamondBase) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassPolyDiamondBase) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassPolyDiamondBase) GetClassName(ctx context.Context) (string, error) {
	res, err := class.CallMethod(ctx, "getClassName")
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}

func NewClassPolyDiamondBase(e embind.Engine, ctx context.Context) (*ClassPolyDiamondBase, error) {
	res, err := e.CallPublicSymbol(ctx, "PolyDiamondBase")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(*ClassPolyDiamondBase), nil
}

type ClassPolyDiamondDerived struct {
	embind.ClassBase
}

func (class *ClassPolyDiamondDerived) Clone(ctx context.Context) (*ClassPolyDiamondDerived, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassPolyDiamondDerived), nil
}

func (class *ClassPolyDiamondDerived) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassPolyDiamondDerived) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassPolyDiamondDerived) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassPolyDiamondDerived) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassPolyDiamondDerived) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassPolyDiamondDerived) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassPolyDiamondDerived) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassPolyDiamondDerived) GetClassName(ctx context.Context) (string, error) {
	res, err := class.CallMethod(ctx, "getClassName")
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}

func NewClassPolyDiamondDerived(e embind.Engine, ctx context.Context) (*ClassPolyDiamondDerived, error) {
	res, err := e.CallPublicSymbol(ctx, "PolyDiamondDerived")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(*ClassPolyDiamondDerived), nil
}

type ClassPolyDiamondMultiplyDerived struct {
	embind.ClassBase
}

func (class *ClassPolyDiamondMultiplyDerived) Clone(ctx context.Context) (*ClassPolyDiamondMultiplyDerived, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassPolyDiamondMultiplyDerived), nil
}

func (class *ClassPolyDiamondMultiplyDerived) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassPolyDiamondMultiplyDerived) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassPolyDiamondMultiplyDerived) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassPolyDiamondMultiplyDerived) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassPolyDiamondMultiplyDerived) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassPolyDiamondMultiplyDerived) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassPolyDiamondMultiplyDerived) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassPolyDiamondMultiplyDerived) GetClassName(ctx context.Context) (string, error) {
	res, err := class.CallMethod(ctx, "getClassName")
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}

func NewClassPolyDiamondMultiplyDerived(e embind.Engine, ctx context.Context) (*ClassPolyDiamondMultiplyDerived, error) {
	res, err := e.CallPublicSymbol(ctx, "PolyDiamondMultiplyDerived")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(*ClassPolyDiamondMultiplyDerived), nil
}

type ClassPolyDiamondSiblingDerived struct {
	embind.ClassBase
}

func (class *ClassPolyDiamondSiblingDerived) Clone(ctx context.Context) (*ClassPolyDiamondSiblingDerived, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassPolyDiamondSiblingDerived), nil
}

func (class *ClassPolyDiamondSiblingDerived) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassPolyDiamondSiblingDerived) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassPolyDiamondSiblingDerived) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassPolyDiamondSiblingDerived) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassPolyDiamondSiblingDerived) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassPolyDiamondSiblingDerived) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassPolyDiamondSiblingDerived) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassPolyDiamondSiblingDerived) GetClassName(ctx context.Context) (string, error) {
	res, err := class.CallMethod(ctx, "getClassName")
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}

func NewClassPolyDiamondSiblingDerived(e embind.Engine, ctx context.Context) (*ClassPolyDiamondSiblingDerived, error) {
	res, err := e.CallPublicSymbol(ctx, "PolyDiamondSiblingDerived")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(*ClassPolyDiamondSiblingDerived), nil
}

type ClassPolyMultiplyDerived struct {
	embind.ClassBase
}

func (class *ClassPolyMultiplyDerived) Clone(ctx context.Context) (*ClassPolyMultiplyDerived, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassPolyMultiplyDerived), nil
}

func (class *ClassPolyMultiplyDerived) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassPolyMultiplyDerived) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassPolyMultiplyDerived) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassPolyMultiplyDerived) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassPolyMultiplyDerived) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassPolyMultiplyDerived) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassPolyMultiplyDerived) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassPolyMultiplyDerived) GetClassName(ctx context.Context) (string, error) {
	res, err := class.CallMethod(ctx, "getClassName")
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}

func (class *ClassPolyMultiplyDerived) VirtualGetClassName(ctx context.Context) (string, error) {
	res, err := class.CallMethod(ctx, "virtualGetClassName")
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}

func NewClassPolyMultiplyDerived(e embind.Engine, ctx context.Context) (*ClassPolyMultiplyDerived, error) {
	res, err := e.CallPublicSymbol(ctx, "PolyMultiplyDerived")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(*ClassPolyMultiplyDerived), nil
}

type ClassPolySecondBase struct {
	embind.ClassBase
}

func (class *ClassPolySecondBase) Clone(ctx context.Context) (*ClassPolySecondBase, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassPolySecondBase), nil
}

func (class *ClassPolySecondBase) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassPolySecondBase) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassPolySecondBase) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassPolySecondBase) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassPolySecondBase) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassPolySecondBase) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassPolySecondBase) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassPolySecondBase) GetClassName(ctx context.Context) (string, error) {
	res, err := class.CallMethod(ctx, "getClassName")
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}

func NewClassPolySecondBase(e embind.Engine, ctx context.Context) (*ClassPolySecondBase, error) {
	res, err := e.CallPublicSymbol(ctx, "PolySecondBase")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(*ClassPolySecondBase), nil
}

type ClassPolySiblingDerived struct {
	embind.ClassBase
}

func (class *ClassPolySiblingDerived) Clone(ctx context.Context) (*ClassPolySiblingDerived, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassPolySiblingDerived), nil
}

func (class *ClassPolySiblingDerived) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassPolySiblingDerived) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassPolySiblingDerived) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassPolySiblingDerived) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassPolySiblingDerived) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassPolySiblingDerived) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassPolySiblingDerived) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassPolySiblingDerived) GetClassName(ctx context.Context) (string, error) {
	res, err := class.CallMethod(ctx, "getClassName")
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}

func (class *ClassPolySiblingDerived) VirtualGetClassName(ctx context.Context) (string, error) {
	res, err := class.CallMethod(ctx, "virtualGetClassName")
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}

func NewClassPolySiblingDerived(e embind.Engine, ctx context.Context) (*ClassPolySiblingDerived, error) {
	res, err := e.CallPublicSymbol(ctx, "PolySiblingDerived")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(*ClassPolySiblingDerived), nil
}

type ClassSecondBase struct {
	embind.ClassBase
}

func (class *ClassSecondBase) Clone(ctx context.Context) (*ClassSecondBase, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassSecondBase), nil
}

func (class *ClassSecondBase) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassSecondBase) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassSecondBase) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassSecondBase) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassSecondBase) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassSecondBase) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassSecondBase) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassSecondBase) GetPropertyMember(ctx context.Context) (int32, error) {
	res, err := class.GetProperty(ctx, "member")
	if err != nil {
		return int32(0), err
	}

	if res == nil {
		return int32(0), nil
	}

	return res.(int32), nil
}
func (class *ClassSecondBase) SetPropertyMember(ctx context.Context, val int32) error {
	return class.SetProperty(ctx, "member", val)
}

func (class *ClassSecondBase) GetPropertySecondBaseMember(ctx context.Context) (int32, error) {
	res, err := class.GetProperty(ctx, "secondBaseMember")
	if err != nil {
		return int32(0), err
	}

	if res == nil {
		return int32(0), nil
	}

	return res.(int32), nil
}
func (class *ClassSecondBase) SetPropertySecondBaseMember(ctx context.Context, val int32) error {
	return class.SetProperty(ctx, "secondBaseMember", val)
}

func (class *ClassSecondBase) GetClassName(ctx context.Context) (string, error) {
	res, err := class.CallMethod(ctx, "getClassName")
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}

func (class *ClassSecondBase) GetClassNameFromSecondBase(ctx context.Context) (string, error) {
	res, err := class.CallMethod(ctx, "getClassNameFromSecondBase")
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}

func (class *ClassSecondBase) GetClassNameNotAvailableInDerivedClasses(ctx context.Context) (string, error) {
	res, err := class.CallMethod(ctx, "getClassNameNotAvailableInDerivedClasses")
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}

func (class *ClassSecondBase) GetMember(ctx context.Context) (int32, error) {
	res, err := class.CallMethod(ctx, "getMember")
	if err != nil {
		return int32(0), err
	}

	if res == nil {
		return int32(0), nil
	}

	return res.(int32), nil
}

func (class *ClassSecondBase) GetSecondBaseMember(ctx context.Context) (int32, error) {
	res, err := class.CallMethod(ctx, "getSecondBaseMember")
	if err != nil {
		return int32(0), err
	}

	if res == nil {
		return int32(0), nil
	}

	return res.(int32), nil
}

func (class *ClassSecondBase) SetMember(ctx context.Context, arg0 int32) error {
	_, err := class.CallMethod(ctx, "setMember", arg0)
	return err
}

func (class *ClassSecondBase) SetSecondBaseMember(ctx context.Context, arg0 int32) error {
	_, err := class.CallMethod(ctx, "setSecondBaseMember", arg0)
	return err
}

func NewClassSecondBase(e embind.Engine, ctx context.Context) (*ClassSecondBase, error) {
	res, err := e.CallPublicSymbol(ctx, "SecondBase")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(*ClassSecondBase), nil
}

type ClassSecondElement struct {
	embind.ClassBase
}

func (class *ClassSecondElement) Clone(ctx context.Context) (*ClassSecondElement, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassSecondElement), nil
}

func (class *ClassSecondElement) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassSecondElement) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassSecondElement) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassSecondElement) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassSecondElement) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassSecondElement) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassSecondElement) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

type ClassSharedPtrHolder struct {
	embind.ClassBase
}

func (class *ClassSharedPtrHolder) Clone(ctx context.Context) (*ClassSharedPtrHolder, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassSharedPtrHolder), nil
}

func (class *ClassSharedPtrHolder) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassSharedPtrHolder) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassSharedPtrHolder) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassSharedPtrHolder) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassSharedPtrHolder) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassSharedPtrHolder) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassSharedPtrHolder) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassSharedPtrHolder) Get(ctx context.Context) (embind.ClassBase, error) {
	res, err := class.CallMethod(ctx, "get")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(embind.ClassBase), nil
}

func (class *ClassSharedPtrHolder) Set(ctx context.Context, arg0 embind.ClassBase) error {
	_, err := class.CallMethod(ctx, "set", arg0)
	return err
}

func NewClassSharedPtrHolder(e embind.Engine, ctx context.Context) (*ClassSharedPtrHolder, error) {
	res, err := e.CallPublicSymbol(ctx, "SharedPtrHolder")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(*ClassSharedPtrHolder), nil
}

type ClassSharedPtrVector struct {
	embind.ClassBase
}

func (class *ClassSharedPtrVector) Clone(ctx context.Context) (*ClassSharedPtrVector, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassSharedPtrVector), nil
}

func (class *ClassSharedPtrVector) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassSharedPtrVector) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassSharedPtrVector) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassSharedPtrVector) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassSharedPtrVector) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassSharedPtrVector) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassSharedPtrVector) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassSharedPtrVector) Get(ctx context.Context, arg0 uint32) (any, error) {
	res, err := class.CallMethod(ctx, "get", arg0)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(any), nil
}

func (class *ClassSharedPtrVector) Push_back(ctx context.Context, arg0 embind.ClassBase) error {
	_, err := class.CallMethod(ctx, "push_back", arg0)
	return err
}

func (class *ClassSharedPtrVector) Resize(ctx context.Context, arg0 uint32, arg1 embind.ClassBase) error {
	_, err := class.CallMethod(ctx, "resize", arg0, arg1)
	return err
}

func (class *ClassSharedPtrVector) Set(ctx context.Context, arg0 uint32, arg1 embind.ClassBase) (bool, error) {
	res, err := class.CallMethod(ctx, "set", arg0, arg1)
	if err != nil {
		return bool(false), err
	}

	if res == nil {
		return bool(false), nil
	}

	return res.(bool), nil
}

func (class *ClassSharedPtrVector) Size(ctx context.Context) (uint32, error) {
	res, err := class.CallMethod(ctx, "size")
	if err != nil {
		return uint32(0), err
	}

	if res == nil {
		return uint32(0), nil
	}

	return res.(uint32), nil
}

func NewClassSharedPtrVector(e embind.Engine, ctx context.Context) (*ClassSharedPtrVector, error) {
	res, err := e.CallPublicSymbol(ctx, "SharedPtrVector")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(*ClassSharedPtrVector), nil
}

type ClassSiblingDerived struct {
	embind.ClassBase
}

func (class *ClassSiblingDerived) Clone(ctx context.Context) (*ClassSiblingDerived, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassSiblingDerived), nil
}

func (class *ClassSiblingDerived) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassSiblingDerived) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassSiblingDerived) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassSiblingDerived) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassSiblingDerived) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassSiblingDerived) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassSiblingDerived) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassSiblingDerived) GetClassName(ctx context.Context) (string, error) {
	res, err := class.CallMethod(ctx, "getClassName")
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}

func NewClassSiblingDerived(e embind.Engine, ctx context.Context) (*ClassSiblingDerived, error) {
	res, err := e.CallPublicSymbol(ctx, "SiblingDerived")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(*ClassSiblingDerived), nil
}

type ClassSmallClass struct {
	embind.ClassBase
}

func (class *ClassSmallClass) Clone(ctx context.Context) (*ClassSmallClass, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassSmallClass), nil
}

func (class *ClassSmallClass) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassSmallClass) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassSmallClass) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassSmallClass) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassSmallClass) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassSmallClass) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassSmallClass) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassSmallClass) GetPropertyMember(ctx context.Context) (int32, error) {
	res, err := class.GetProperty(ctx, "member")
	if err != nil {
		return int32(0), err
	}

	if res == nil {
		return int32(0), nil
	}

	return res.(int32), nil
}
func (class *ClassSmallClass) SetPropertyMember(ctx context.Context, val int32) error {
	return class.SetProperty(ctx, "member", val)
}

func NewClassSmallClass(e embind.Engine, ctx context.Context) (*ClassSmallClass, error) {
	res, err := e.CallPublicSymbol(ctx, "SmallClass")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(*ClassSmallClass), nil
}

type ClassStringFunctorString struct {
	embind.ClassBase
}

func (class *ClassStringFunctorString) Clone(ctx context.Context) (*ClassStringFunctorString, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassStringFunctorString), nil
}

func (class *ClassStringFunctorString) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassStringFunctorString) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassStringFunctorString) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassStringFunctorString) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassStringFunctorString) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassStringFunctorString) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassStringFunctorString) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassStringFunctorString) Opcall(ctx context.Context, arg0 string) (string, error) {
	res, err := class.CallMethod(ctx, "opcall", arg0)
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}

func NewClassStringFunctorString(e embind.Engine, ctx context.Context) (*ClassStringFunctorString, error) {
	res, err := e.CallPublicSymbol(ctx, "StringFunctorString")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(*ClassStringFunctorString), nil
}

type ClassStringHolder struct {
	embind.ClassBase
}

func (class *ClassStringHolder) Clone(ctx context.Context) (*ClassStringHolder, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassStringHolder), nil
}

func (class *ClassStringHolder) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassStringHolder) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassStringHolder) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassStringHolder) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassStringHolder) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassStringHolder) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassStringHolder) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassStringHolder) Get(ctx context.Context) (string, error) {
	res, err := class.CallMethod(ctx, "get")
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}

func (class *ClassStringHolder) Get_const_ref(ctx context.Context) (string, error) {
	res, err := class.CallMethod(ctx, "get_const_ref")
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}

func (class *ClassStringHolder) Set(ctx context.Context, arg0 string) error {
	_, err := class.CallMethod(ctx, "set", arg0)
	return err
}

func NewClassStringHolder(e embind.Engine, ctx context.Context, arg0 string) (*ClassStringHolder, error) {
	res, err := e.CallPublicSymbol(ctx, "StringHolder", arg0)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(*ClassStringHolder), nil
}

type ClassStringHolderVector struct {
	embind.ClassBase
}

func (class *ClassStringHolderVector) Clone(ctx context.Context) (*ClassStringHolderVector, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassStringHolderVector), nil
}

func (class *ClassStringHolderVector) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassStringHolderVector) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassStringHolderVector) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassStringHolderVector) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassStringHolderVector) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassStringHolderVector) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassStringHolderVector) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassStringHolderVector) Get(ctx context.Context, arg0 uint32) (any, error) {
	res, err := class.CallMethod(ctx, "get", arg0)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(any), nil
}

func (class *ClassStringHolderVector) Push_back(ctx context.Context, arg0 embind.ClassBase) error {
	_, err := class.CallMethod(ctx, "push_back", arg0)
	return err
}

func (class *ClassStringHolderVector) Resize(ctx context.Context, arg0 uint32, arg1 embind.ClassBase) error {
	_, err := class.CallMethod(ctx, "resize", arg0, arg1)
	return err
}

func (class *ClassStringHolderVector) Set(ctx context.Context, arg0 uint32, arg1 embind.ClassBase) (bool, error) {
	res, err := class.CallMethod(ctx, "set", arg0, arg1)
	if err != nil {
		return bool(false), err
	}

	if res == nil {
		return bool(false), nil
	}

	return res.(bool), nil
}

func (class *ClassStringHolderVector) Size(ctx context.Context) (uint32, error) {
	res, err := class.CallMethod(ctx, "size")
	if err != nil {
		return uint32(0), err
	}

	if res == nil {
		return uint32(0), nil
	}

	return res.(uint32), nil
}

func NewClassStringHolderVector(e embind.Engine, ctx context.Context) (*ClassStringHolderVector, error) {
	res, err := e.CallPublicSymbol(ctx, "StringHolderVector")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(*ClassStringHolderVector), nil
}

type ClassStringIntMap struct {
	embind.ClassBase
}

func (class *ClassStringIntMap) Clone(ctx context.Context) (*ClassStringIntMap, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassStringIntMap), nil
}

func (class *ClassStringIntMap) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassStringIntMap) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassStringIntMap) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassStringIntMap) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassStringIntMap) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassStringIntMap) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassStringIntMap) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassStringIntMap) Get(ctx context.Context, arg0 string) (any, error) {
	res, err := class.CallMethod(ctx, "get", arg0)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(any), nil
}

func (class *ClassStringIntMap) Keys(ctx context.Context) (embind.ClassBase, error) {
	res, err := class.CallMethod(ctx, "keys")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(embind.ClassBase), nil
}

func (class *ClassStringIntMap) Set(ctx context.Context, arg0 string, arg1 int32) error {
	_, err := class.CallMethod(ctx, "set", arg0, arg1)
	return err
}

func (class *ClassStringIntMap) Size(ctx context.Context) (uint32, error) {
	res, err := class.CallMethod(ctx, "size")
	if err != nil {
		return uint32(0), err
	}

	if res == nil {
		return uint32(0), nil
	}

	return res.(uint32), nil
}

func NewClassStringIntMap(e embind.Engine, ctx context.Context) (*ClassStringIntMap, error) {
	res, err := e.CallPublicSymbol(ctx, "StringIntMap")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(*ClassStringIntMap), nil
}

type ClassStringVector struct {
	embind.ClassBase
}

func (class *ClassStringVector) Clone(ctx context.Context) (*ClassStringVector, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassStringVector), nil
}

func (class *ClassStringVector) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassStringVector) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassStringVector) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassStringVector) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassStringVector) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassStringVector) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassStringVector) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassStringVector) Get(ctx context.Context, arg0 uint32) (any, error) {
	res, err := class.CallMethod(ctx, "get", arg0)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(any), nil
}

func (class *ClassStringVector) Push_back(ctx context.Context, arg0 string) error {
	_, err := class.CallMethod(ctx, "push_back", arg0)
	return err
}

func (class *ClassStringVector) Resize(ctx context.Context, arg0 uint32, arg1 string) error {
	_, err := class.CallMethod(ctx, "resize", arg0, arg1)
	return err
}

func (class *ClassStringVector) Set(ctx context.Context, arg0 uint32, arg1 string) (bool, error) {
	res, err := class.CallMethod(ctx, "set", arg0, arg1)
	if err != nil {
		return bool(false), err
	}

	if res == nil {
		return bool(false), nil
	}

	return res.(bool), nil
}

func (class *ClassStringVector) Size(ctx context.Context) (uint32, error) {
	res, err := class.CallMethod(ctx, "size")
	if err != nil {
		return uint32(0), err
	}

	if res == nil {
		return uint32(0), nil
	}

	return res.(uint32), nil
}

func NewClassStringVector(e embind.Engine, ctx context.Context) (*ClassStringVector, error) {
	res, err := e.CallPublicSymbol(ctx, "StringVector")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(*ClassStringVector), nil
}

type ClassUniquePtrLifetimeMock struct {
	embind.ClassBase
}

func (class *ClassUniquePtrLifetimeMock) Clone(ctx context.Context) (*ClassUniquePtrLifetimeMock, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassUniquePtrLifetimeMock), nil
}

func (class *ClassUniquePtrLifetimeMock) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassUniquePtrLifetimeMock) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassUniquePtrLifetimeMock) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassUniquePtrLifetimeMock) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassUniquePtrLifetimeMock) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassUniquePtrLifetimeMock) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassUniquePtrLifetimeMock) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

type ClassUniquePtrToConstructor struct {
	embind.ClassBase
}

func (class *ClassUniquePtrToConstructor) Clone(ctx context.Context) (*ClassUniquePtrToConstructor, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassUniquePtrToConstructor), nil
}

func (class *ClassUniquePtrToConstructor) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassUniquePtrToConstructor) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassUniquePtrToConstructor) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassUniquePtrToConstructor) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassUniquePtrToConstructor) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassUniquePtrToConstructor) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassUniquePtrToConstructor) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassUniquePtrToConstructor) GetValue(ctx context.Context) (int32, error) {
	res, err := class.CallMethod(ctx, "getValue")
	if err != nil {
		return int32(0), err
	}

	if res == nil {
		return int32(0), nil
	}

	return res.(int32), nil
}

type ClassValHolder struct {
	embind.ClassBase
}

func (class *ClassValHolder) Clone(ctx context.Context) (*ClassValHolder, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassValHolder), nil
}

func (class *ClassValHolder) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassValHolder) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassValHolder) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassValHolder) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassValHolder) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassValHolder) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassValHolder) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassValHolder) GetPropertyFunction_val(ctx context.Context) (any, error) {
	res, err := class.GetProperty(ctx, "function_val")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(any), nil
}
func (class *ClassValHolder) SetPropertyFunction_val(ctx context.Context, val any) error {
	return class.SetProperty(ctx, "function_val", val)
}

func (class *ClassValHolder) GetPropertyFunctor_val(ctx context.Context) (any, error) {
	res, err := class.GetProperty(ctx, "functor_val")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(any), nil
}
func (class *ClassValHolder) SetPropertyFunctor_val(ctx context.Context, val any) error {
	return class.SetProperty(ctx, "functor_val", val)
}

func (class *ClassValHolder) GetPropertyReadonly_function_val(ctx context.Context) (any, error) {
	res, err := class.GetProperty(ctx, "readonly_function_val")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(any), nil
}

func (class *ClassValHolder) GetPropertyReadonly_functor_val(ctx context.Context) (any, error) {
	res, err := class.GetProperty(ctx, "readonly_functor_val")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(any), nil
}

func (class *ClassValHolder) GetPropertyVal(ctx context.Context) (any, error) {
	res, err := class.GetProperty(ctx, "val")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(any), nil
}
func (class *ClassValHolder) SetPropertyVal(ctx context.Context, val any) error {
	return class.SetProperty(ctx, "val", val)
}

func (class *ClassValHolder) GetPropertyVal_readonly(ctx context.Context) (any, error) {
	res, err := class.GetProperty(ctx, "val_readonly")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(any), nil
}

func (class *ClassValHolder) GetConstVal(ctx context.Context) (any, error) {
	res, err := class.CallMethod(ctx, "getConstVal")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(any), nil
}

func (class *ClassValHolder) GetVal(ctx context.Context) (any, error) {
	res, err := class.CallMethod(ctx, "getVal")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(any), nil
}

func (class *ClassValHolder) GetValConstRef(ctx context.Context) (any, error) {
	res, err := class.CallMethod(ctx, "getValConstRef")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(any), nil
}

func (class *ClassValHolder) GetValFunction(ctx context.Context) (any, error) {
	res, err := class.CallMethod(ctx, "getValFunction")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(any), nil
}

func (class *ClassValHolder) GetValFunctor(ctx context.Context) (any, error) {
	res, err := class.CallMethod(ctx, "getValFunctor")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(any), nil
}

func (class *ClassValHolder) GetValNonConst(ctx context.Context) (any, error) {
	res, err := class.CallMethod(ctx, "getValNonConst")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(any), nil
}

func (class *ClassValHolder) GetValNonMember(ctx context.Context) (any, error) {
	res, err := class.CallMethod(ctx, "getValNonMember")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(any), nil
}

func (class *ClassValHolder) SetEmpty(ctx context.Context) error {
	_, err := class.CallMethod(ctx, "setEmpty")
	return err
}

func (class *ClassValHolder) SetVal(ctx context.Context, arg0 any) error {
	_, err := class.CallMethod(ctx, "setVal", arg0)
	return err
}

func (class *ClassValHolder) SetValFunction(ctx context.Context, arg0 any) error {
	_, err := class.CallMethod(ctx, "setValFunction", arg0)
	return err
}

func (class *ClassValHolder) SetValFunctor(ctx context.Context, arg0 any) error {
	_, err := class.CallMethod(ctx, "setValFunctor", arg0)
	return err
}

func (class *ClassValHolder) StaticGet_via_raw_pointer(ctx context.Context, arg0 embind.ClassBase) (any, error) {
	res, err := class.CallInstanceMethod(ctx, nil, "get_via_raw_pointer", arg0)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(any), nil
}
func ClassValHolderStaticGet_via_raw_pointer(e embind.Engine, ctx context.Context, arg0 embind.ClassBase) (any, error) {
	res, err := e.CallStaticClassMethod(ctx, "ValHolder", "get_via_raw_pointer", arg0)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(any), nil
}

func (class *ClassValHolder) StaticMakeConst(ctx context.Context, arg0 any) (embind.ClassBase, error) {
	res, err := class.CallInstanceMethod(ctx, nil, "makeConst", arg0)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(embind.ClassBase), nil
}
func ClassValHolderStaticMakeConst(e embind.Engine, ctx context.Context, arg0 any) (embind.ClassBase, error) {
	res, err := e.CallStaticClassMethod(ctx, "ValHolder", "makeConst", arg0)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(embind.ClassBase), nil
}

func (class *ClassValHolder) StaticMakeValHolder(ctx context.Context, arg0 any) (embind.ClassBase, error) {
	res, err := class.CallInstanceMethod(ctx, nil, "makeValHolder", arg0)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(embind.ClassBase), nil
}
func ClassValHolderStaticMakeValHolder(e embind.Engine, ctx context.Context, arg0 any) (embind.ClassBase, error) {
	res, err := e.CallStaticClassMethod(ctx, "ValHolder", "makeValHolder", arg0)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(embind.ClassBase), nil
}

func (class *ClassValHolder) StaticSet_via_raw_pointer(ctx context.Context, arg0 embind.ClassBase, arg1 any) error {
	_, err := class.CallInstanceMethod(ctx, nil, "set_via_raw_pointer", arg0, arg1)
	return err
}
func ClassValHolderStaticSet_via_raw_pointer(e embind.Engine, ctx context.Context, arg0 embind.ClassBase, arg1 any) error {
	_, err := e.CallStaticClassMethod(ctx, "ValHolder", "set_via_raw_pointer", arg0, arg1)
	return err
}

func (class *ClassValHolder) StaticSome_class_method(ctx context.Context, arg0 int32) (int32, error) {
	res, err := class.CallInstanceMethod(ctx, nil, "some_class_method", arg0)
	if err != nil {
		return int32(0), err
	}

	if res == nil {
		return int32(0), nil
	}

	return res.(int32), nil
}
func ClassValHolderStaticSome_class_method(e embind.Engine, ctx context.Context, arg0 int32) (int32, error) {
	res, err := e.CallStaticClassMethod(ctx, "ValHolder", "some_class_method", arg0)
	if err != nil {
		return int32(0), err
	}

	if res == nil {
		return int32(0), nil
	}

	return res.(int32), nil
}

func (class *ClassValHolder) StaticTransfer_via_raw_pointer(ctx context.Context, arg0 embind.ClassBase, arg1 embind.ClassBase) error {
	_, err := class.CallInstanceMethod(ctx, nil, "transfer_via_raw_pointer", arg0, arg1)
	return err
}
func ClassValHolderStaticTransfer_via_raw_pointer(e embind.Engine, ctx context.Context, arg0 embind.ClassBase, arg1 embind.ClassBase) error {
	_, err := e.CallStaticClassMethod(ctx, "ValHolder", "transfer_via_raw_pointer", arg0, arg1)
	return err
}

func NewClassValHolder(e embind.Engine, ctx context.Context, arg0 any) (*ClassValHolder, error) {
	res, err := e.CallPublicSymbol(ctx, "ValHolder", arg0)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(*ClassValHolder), nil
}

type ClassVectorHolder struct {
	embind.ClassBase
}

func (class *ClassVectorHolder) Clone(ctx context.Context) (*ClassVectorHolder, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassVectorHolder), nil
}

func (class *ClassVectorHolder) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassVectorHolder) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassVectorHolder) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassVectorHolder) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassVectorHolder) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassVectorHolder) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassVectorHolder) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassVectorHolder) Get(ctx context.Context) (embind.ClassBase, error) {
	res, err := class.CallMethod(ctx, "get")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(embind.ClassBase), nil
}

func (class *ClassVectorHolder) Set(ctx context.Context, arg0 embind.ClassBase) error {
	_, err := class.CallMethod(ctx, "set", arg0)
	return err
}

func NewClassVectorHolder(e embind.Engine, ctx context.Context) (*ClassVectorHolder, error) {
	res, err := e.CallPublicSymbol(ctx, "VectorHolder")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(*ClassVectorHolder), nil
}

type ClassVectorUnsigned struct {
	embind.ClassBase
}

func (class *ClassVectorUnsigned) Clone(ctx context.Context) (*ClassVectorUnsigned, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassVectorUnsigned), nil
}

func (class *ClassVectorUnsigned) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassVectorUnsigned) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassVectorUnsigned) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassVectorUnsigned) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassVectorUnsigned) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassVectorUnsigned) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassVectorUnsigned) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassVectorUnsigned) Get(ctx context.Context, arg0 uint32) (any, error) {
	res, err := class.CallMethod(ctx, "get", arg0)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(any), nil
}

func (class *ClassVectorUnsigned) Push_back(ctx context.Context, arg0 uint32) error {
	_, err := class.CallMethod(ctx, "push_back", arg0)
	return err
}

func (class *ClassVectorUnsigned) Resize(ctx context.Context, arg0 uint32, arg1 uint32) error {
	_, err := class.CallMethod(ctx, "resize", arg0, arg1)
	return err
}

func (class *ClassVectorUnsigned) Set(ctx context.Context, arg0 uint32, arg1 uint32) (bool, error) {
	res, err := class.CallMethod(ctx, "set", arg0, arg1)
	if err != nil {
		return bool(false), err
	}

	if res == nil {
		return bool(false), nil
	}

	return res.(bool), nil
}

func (class *ClassVectorUnsigned) Size(ctx context.Context) (uint32, error) {
	res, err := class.CallMethod(ctx, "size")
	if err != nil {
		return uint32(0), err
	}

	if res == nil {
		return uint32(0), nil
	}

	return res.(uint32), nil
}

func NewClassVectorUnsigned(e embind.Engine, ctx context.Context) (*ClassVectorUnsigned, error) {
	res, err := e.CallPublicSymbol(ctx, "VectorUnsigned")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(*ClassVectorUnsigned), nil
}

type ClassVectorUnsignedChar struct {
	embind.ClassBase
}

func (class *ClassVectorUnsignedChar) Clone(ctx context.Context) (*ClassVectorUnsignedChar, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassVectorUnsignedChar), nil
}

func (class *ClassVectorUnsignedChar) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassVectorUnsignedChar) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassVectorUnsignedChar) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassVectorUnsignedChar) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassVectorUnsignedChar) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassVectorUnsignedChar) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassVectorUnsignedChar) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassVectorUnsignedChar) Get(ctx context.Context, arg0 uint32) (any, error) {
	res, err := class.CallMethod(ctx, "get", arg0)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(any), nil
}

func (class *ClassVectorUnsignedChar) Push_back(ctx context.Context, arg0 uint8) error {
	_, err := class.CallMethod(ctx, "push_back", arg0)
	return err
}

func (class *ClassVectorUnsignedChar) Resize(ctx context.Context, arg0 uint32, arg1 uint8) error {
	_, err := class.CallMethod(ctx, "resize", arg0, arg1)
	return err
}

func (class *ClassVectorUnsignedChar) Set(ctx context.Context, arg0 uint32, arg1 uint8) (bool, error) {
	res, err := class.CallMethod(ctx, "set", arg0, arg1)
	if err != nil {
		return bool(false), err
	}

	if res == nil {
		return bool(false), nil
	}

	return res.(bool), nil
}

func (class *ClassVectorUnsignedChar) Size(ctx context.Context) (uint32, error) {
	res, err := class.CallMethod(ctx, "size")
	if err != nil {
		return uint32(0), err
	}

	if res == nil {
		return uint32(0), nil
	}

	return res.(uint32), nil
}

func NewClassVectorUnsignedChar(e embind.Engine, ctx context.Context) (*ClassVectorUnsignedChar, error) {
	res, err := e.CallPublicSymbol(ctx, "VectorUnsignedChar")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(*ClassVectorUnsignedChar), nil
}
